config:
  HAS_SETTINGS: 1
  HAS_AT_SERVER: 1
  PROD_START_BOOTLOADER_CMD: 1
  PROD_DEVICE_DATA_RW_CMD: 1
  PROD_PHY_AT_CMD: 0
  HAS_TX_BLE_TX_POWER_SETTING: 1
  HAS_COORDINATOR: 1
  HAS_WIFI: 1
  HAS_BLE: 1
  DEFAULT_BLE_MODE: 3
  DEFAULT_BLE_CHARACTERISTICS_LENGTH: 244
  DEFAULT_BAUDRATE: 115200
  DEFAULT_FLOW_CONTROL: 0
  HAS_SYSTEM_COMMON: 1
  BAUDRATE_VALUES: 110..6000000
  FLOW_CTRL_ENABLED: 1
  FLOW_CTRL_DISABLED: 0
  HAS_SYSTEM: 1
  HAS_RADIO_COEX: 0
  HAS_SYSTIME: 1
  HAS_CHIP_DIE_TEMP_SENSOR: 0
  HAS_SYSTEM_INTERFACE: 1
  HAS_BLE_CODED_PHY: 0
  HAS_BLE_EXT_ADV: 0
  HAS_GAP_CENTRAL: 1
  HAS_CHANNEL_SOUNDING: 0
  MAX_BLE_CENTRAL_CONNECTION_COUNT: 3
  MAX_BLE_PERIPHERAL_CONNECTION_COUNT: 1
  MAX_BLE_ADV_DATA_LEN: 28
  MAX_BLE_SCAN_RSP_DATA_LEN: 31
  MAX_BLE_EXT_ADV_DATA_LEN: 223
  MAX_IDX_BLE_EXT_ADV: 0
  MAX_BLE_BONDED_DEVICE_COUNT: 20
  MAX_BLE_GATT_SERVER_CCCD_CHAR_COUNT: 23
  HAS_GATT_CLIENT: 1
  HAS_GATT_SERVER: 1
  HAS_SERVICE_CHANGE_INDICATION: 1
  HAS_SPS: 1
  SPS_RX_BUFFER_SIZE: 8192
  WIFI_MAX_SSID_LENGTH: 32
  WIFI_MAX_PASSPHRASE_LENGTH: 63
  WIFI_CHANNEL_LIST_LENGTH_MAX: 40
  PEAP_CRED_SIZE: 31
  EAP_TLS_IDENTITY_SIZE: 31
  HOSTNAME_SIZE: 40
  HAS_SOCKET: 1
  IP_MAX_STRING_DATA_LEN: 1000
  MAX_SOCKET_COUNT: 6
  HAS_MQTT: 1
  MAX_TOPIC_SIZE: 256
  MAX_SUB_MSG_SIZE: 1000
  MAX_SUB_MSG_BINARY_DATA_SIZE: 5000
  MAX_PUB_MSG_SIZE: 5000
  DEFAULT_MQTT_KEEPALIVE: 60
  MAX_BROKERNAME_SIZE: 128
  MAX_USERNAME_PASSW_SIZE: 128
  MAX_CLIENT_ID_SIZE: 128
  HAS_HTTPC: 1
  HTTP_MAX_PATH_LENGTH: 300
  HTTP_MAX_HOST_LENGTH: 300
  HTTP_MAX_HEADER_FIELD_NAME_LENGTH: 30
  HTTP_MAX_HEADER_FIELD_VALUE_LENGTH: 70
  HTTP_MAX_HEADER_FIELDS: 10
  HAS_NETWORK_TIME: 1
  HAS_POWER_MANAGER: 1
  HAS_EXTENDED_SLEEP_MODES: 0
  HAS_SLEEP_CMD: 0
  HAS_DEEP_SLEEP_CMD: 1
  HAS_TRANSPARENT_MODE_PERSISTENT: 1
  MIN_DESTINATION_ADDR_SIZE: 4
  MAX_DESTINATION_ADDR_SIZE: 80
  HAS_COORDINATOR_SHARED_LOW: 1
  HAS_COORDINATOR_SHARED_HIGH: 1
  HAS_COORDINATOR_DEDICATED: 0
  COORDINATOR_SHARED_LOW_PRIORITY: 7
  COORDINATOR_SHARED_LOW_STACK_SIZE: 4096
  COORDINATOR_SHARED_LOW_NAME: coordinatorLow
  COORDINATOR_SHARED_LOW_MODULE_COUNT: 1
  COORDINATOR_SHARED_HIGH_PRIORITY: 2
  COORDINATOR_SHARED_HIGH_STACK_SIZE: 4096
  COORDINATOR_SHARED_HIGH_NAME: coordinatorHigh
  COORDINATOR_SHARED_HIGH_MODULE_COUNT: 1
  COORDINATOR_DEDICATED_MODULE_COUNT: 1
  STORE_CERTIFICATES_AS_FILES: 1
  APP_U_CONNECT_XPRESS: 1
  LOG_USE_ANSI_COLOR: 1
  LOG_USE_RTT: 0
  DFM: 1
  TRACE_REC: 0
  MUTEX_DEADLOCK_DETECTION: 0
  PRODUCT: NORA-W36
command_groups:
  General:
    urcs:
      +STARTUP:
        brief: Startup indication
        api_name: Startup
        desc: Indicates the startup of the device and that it is ready to receive
          commands.
        notes: The +STARTUP URC can be customized using the AT+CSGT command.
    commands:
      AT:
        brief: Attention
        desc: Attention command that determines the presence of a Data Communication
          Equipment (DCE).
        syntax:
          AT:
            api_name: Attention
            desc: Attention command.
      AT+CGMI:
        brief: Manufacturer identification
        desc: Read a text string that identifies the manufacturer.
        syntax:
          AT+CGMI:
            desc: Read manufacturer text string.
            responses:
              <manufacturer>:
                desc: "Successful read response.\nNote: The manufacturer string is\
                  \ returned without any response prefix.\n"
      AT+GMI:
        brief: Manufacturer identification
        desc: Read a text string that identifies the manufacturer.
        syntax:
          AT+GMI:
            api_name: GetManufacturerIdentification
            desc: Read manufacturer text string.
            responses:
              <manufacturer>:
                desc: "Successful read response.\nNote: The manufacturer string is\
                  \ returned without any response prefix.\n"
      AT+CGMM:
        brief: Model identification
        desc: Read a text string that identifies the device model.
        syntax:
          AT+CGMM:
            desc: Read device model.
            responses:
              <device_model>:
                desc: "Successful read response.\nNote: The device_model string is\
                  \ returned without any response prefix.\n"
      AT+GMM:
        brief: Model identification
        desc: Read a text string that identifies the device model.
        syntax:
          AT+GMM:
            api_name: GetDeviceModelIdentification
            desc: Read device model.
            responses:
              <device_model>:
                desc: "Successful read response.\nNote: The device_model string is\
                  \ returned without any response prefix.\n"
      AT+CGMR:
        brief: Software version identification
        desc: Read a text string that identifies the software version of the module.
        syntax:
          AT+CGMR:
            desc: Read software version.
            responses:
              <version>:
                desc: "Successful read response.\nNote: The version string is returned\
                  \ without any response prefix.\n"
      AT+GMR:
        brief: Software version identification
        desc: Read a text string that identifies the software version of the module.
        syntax:
          AT+GMR:
            api_name: GetSoftwareVersion
            desc: Read software version.
            responses:
              <version>:
                desc: "Successful read response.\nNote: The version string is returned\
                  \ without any response prefix.\n"
      AT+CGSN:
        brief: Serial number
        desc: Read the product serial number.
        syntax:
          AT+CGSN:
            desc: Read serial number.
            responses:
              <serial_number>:
                desc: "Successful read response.\nNote: The serial_number string is\
                  \ returned without any response prefix.\n"
      AT+GSN:
        brief: Serial number
        desc: Read the product serial number.
        syntax:
          AT+GSN:
            api_name: GetSerialNumber
            desc: Read serial number.
            responses:
              <serial_number>:
                desc: "Successful read response.\nNote: The serial_number string is\
                  \ returned without any response prefix.\n"
      ATI:
        brief: Identification information
        desc: Read identification information.
        syntax:
          ATI9:
            api_name: GetIdentInfo
            desc: Read identification information.
            responses:
              <application_version>,<unique_identifier>:
                desc: "Successful read response.\nNote: The application_version and\
                  \ unique_identifier strings are returned without any response prefix.\n"
          ATI0:
            api_name: GetTypeCode
            desc: Read type code.
            responses:
              <type_code>:
                desc: "Successful read response.\nNote: The type_code string is returned\
                  \ without any response prefix.\n"
        parameters:
          application_version:
            type: string
            desc: Application version.
          unique_identifier:
            type: string
            desc: Unique identifier.
          type_code:
            type: string
            desc: Type code for the module.
      AT+CSGT:
        brief: Greeting Text
        desc: "Configures and activates/deactivates the greeting text.\nThe configuration\
          \ change in the greeting text will be applied at the subsequent boot.\n\
          When active, the greeting text is sent at boot once. The default greeting\
          \ text is +STARTUP.\n"
        syntax:
          AT+CSGT=<greeting_mode>[,<text>]:
            api_name: SetGreetingText
            storable: true
            requires_reboot: true
            desc: Set the greeting text and mode.
          AT+CSGT?:
            api_name: GetGreetingText
            desc: Read the greeting text.
            responses:
              +CSGT:<greeting_mode>,<text>:
                desc: Successful read response.
        parameters:
          greeting_mode:
            type: enumerator
            values:
              off:
                value: 0
                desc: Turn off the greeting text.
              on:
                value: 1
                desc: Turn on the greeting text.
          text:
            desc: "The greeting text.\nNote: Can not be an empty string.\n"
            type: string
            length: 1..49
    parameters:
      device_model:
        type: string
        desc: Device model
      serial_number:
        type: string
        desc: Serial number.
      manufacturer:
        type: string
        desc: Manufacturer ("u-blox").
      version:
        type: string
        desc: Version.
  System:
    type_prefix: sys
    parameters:
      baud_rate:
        type: integer
        desc: Baudrate
        default: U_CONFIG_DEFAULT_BAUDRATE
        valid_values: 110..6000000
      slot:
        type: enumerator
        values:
          firmware_slot1:
            desc: Slot 1.
            value: 0
          firmware_slot2:
            desc: Slot 2.
            value: 1
    desc: System AT commands
    commands:
      AT+CPWROFF:
        brief: Module switch off
        syntax:
          AT+CPWROFF:
            api_name: Reboot
            desc: Reboot the DCE.
      AT+USYIIS:
        visibility: hidden
        brief: Invalidate Image slot
        desc: Invalidates selected firmware slot.
        syntax:
          AT+USYIIS:
            desc: Invalidate the currently active firmware slot.
          AT+USYIIS=<slot>:
            desc: Invalidate the firmware image from the given slot.
      AT+USYFWU:
        visibility: hidden
        brief: Firmware Update
        desc: Force start of the boot loader. The boot loader will start at the defined
          baud rate.
        syntax:
          AT+USYFWU=<bootloader_mode>,<baud_rate>[,<flow_control>]:
            desc: Force start of the boot loader.
        parameters:
          bootloader_mode:
            type: bootloader_mode
          flow_control:
            type: integer
            default: U_CONFIG_DEFAULT_FLOW_CONTROL
            valid_values: 0..1
      AT+USYFWUS:
        brief: Firmware Update using serial port
        desc: "Start serial port firmware upgrade. The module will indicate that it\
          \ is ready to receive\nthe new firmware by regularly sending the XModem\
          \ start byte C until either an XModem transfer has started,\nor a timeout\
          \ has occurred\n"
        syntax:
          AT+USYFWUS=<baud_rate>[,<flow_control>]:
            api_name: StartSerialFirmwareUpdate
            desc: Start firmware upgrade on the serial port with provided settings
          AT+USYFWUS:
            api_name: StartSerialFirmwareUpdateDefault
            desc: Start firmware upgrade on the serial port with default settings,
              baudrate 115200 and no flow control
        parameters:
          flow_control:
            type: integer
            default: 0
            valid_values: 0..1
      AT+USYBL:
        brief: Start the boot loader command line interface
        desc: Force start of the boot loader. The boot loader will start at the defined
          baud rate.
        syntax:
          AT+USYBL=<baud_rate>[,<flow_control>]:
            api_name: StartBootLoader
            desc: Force start of the boot loader.
          AT+USYBL:
            api_name: StartBootLoaderDefault
            desc: Force start of the boot loader with default settings. Baudrate 115200
              and flow control off.
        parameters:
          flow_control:
            type: integer
            default: 0
            valid_values: 0..1
      AT&W:
        brief: Store current configuration
        desc: Store the current configuration to flash
        syntax:
          AT&W:
            api_name: StoreConfiguration
            desc: Write the current configuration to flash. The configuration is stored
              immediately when AT&W is issued.
      AT+USYCI:
        visibility: hidden
        brief: Crash Information
        syntax:
          AT+USYCI?:
            desc: Read information about the latest crash
            responses:
              +USYCI:<crash_type>,<task_name>,<file_name>,<line_nr>,<fw_version>:
                desc: Assert information
              +USYCI:<crash_type>,<task_name>,<fw_version>:
                desc: Stack overflow information
              +USYCI:<crash_type>,<task_name>,<fw_version>,<reg_string>:
                desc: Watchdog information
        parameters:
          crash_type:
            type: string
          task_name:
            type: string
          file_name:
            type: string
          line_nr:
            type: integer
          fw_version:
            type: string
          reg_string:
            type: string
      AT+USYA:
        visibility: hidden
        brief: Assert
        syntax:
          AT+USYA=<failure_type>:
            desc: Trigger a software failure in module to test the functionality
        parameters:
          failure_type:
            type: enumerator
            values:
              null_pointer:
                desc: Null pointer
                value: 0
              watchdog:
                desc: Watchdog
                value: 1
              assert:
                desc: Assert
                value: 2
              stack_overflow:
                desc: Stack overflow
                value: 5
      AT+USYLA:
        brief: Local Address
        syntax:
          AT+USYLA=<interface_id>:
            api_name: GetLocalAddress
            desc: Get interface address
            responses:
              +USYLA:<address>:
                desc: Successful read response
          AT+USYLA=<interface_id>,<address>:
            api_name: SetLocalAddress
            desc: Set interface address
            requires_reboot: true
            storable: true
        parameters:
          interface_id:
            type: interface_id
          address:
            desc: MAC address of the interface id. If the address is set to 000000000000,
              the local address will be restored to factory-programmed value. The
              least significant bit of the first octet of the address must be 0.
            type: mac_addr
      AT+USYFR:
        brief: Factory Restore
        syntax:
          AT+USYFR:
            api_name: FactoryReset
            requires_reboot: true
            storable: true
            desc: "The module is completely restored to factory defaults. All settings\
              \ are reset to default values.\nAll certificates and Bluetooth bonding\
              \ information will be removed.\n"
      AT+USYDS:
        brief: Default Settings
        syntax:
          AT+USYDS:
            api_name: DefaultSettings
            requires_reboot: true
            storable: true
            desc: "Reset all settings to default values.\nCertificates and Bluetooth\
              \ bonding information will be left untouched.\n"
      AT+USYUS:
        brief: Uart Settings
        syntax:
          AT+USYUS=<baud_rate>[,<flow_control>[,<change_after_confirm>]]:
            storable: true
            api_name: SetUartSettings
            desc: Configure new UART settings that will be used after restart. Baudrates
              above 4000000 bps can be set, but are unsupported. If the flow_control
              parameter is omitted then no flow control will be used. If change_after_confirm
              is not provided the baudrate will be changed only after a store and
              reboot.
          AT+USYUS?:
            api_name: GetUartSettings
            desc: Reads current UART settings from the module
            responses:
              +USYUS:<baud_rate>,<flow_control>:
                desc: Successful read response
        parameters:
          flow_control:
            type: integer
            valid_values: 0..1
            desc: "0: No flow control\n1: Use CTS/RTS flow control\n"
          change_after_confirm:
            type: integer
            valid_values: 0..1
            desc: "0: Switch baudrate after reboot. When set ${ref:AT&W} must be called.\n\
              1: Switch baudrate directly after status OK have been sent.\n"
      AT+USYSWDD:
        visibility: hidden
        brief: SWD interface Disable
        syntax:
          AT+USYSWDD:
            desc: Disable SWD interface.
      AT+USYSWDS:
        visibility: hidden
        brief: SWD interface State
        syntax:
          AT+USYSWDS?:
            desc: Read SWD interface state.
            responses:
              +USYSWDS:<state>:
                desc: SWD interface state response.
        parameters:
          state:
            desc: SWD interface state
            type: enumerator
            values:
              disabled:
                desc: SWD interface is disabled
                value: 0
              enabled:
                desc: SWD interface is enabled
                value: 1
      AT+USYAIS:
        visibility: hidden
        brief: Active Image Slot.
        syntax:
          AT+USYAIS=<slot>:
            desc: Set active slot.
          AT+USYAIS?:
            desc: Read active slot.
            responses:
              +USYAIS:<slot>:
                desc: Response with current active slot.
      AT+USYLAOTP:
        brief: Local Address in OTP
        visibility: hidden
        syntax:
          AT+USYLAOTP=<interface_id>,<mac_addr>:
            desc: Write local address for the specified interface to OTP.
        parameters:
          interface_id:
            type: interface_id
            desc: Interface Id to program the mac for. Only BT and Wi-Fi station allowed.
              AP will be Wi-Fi station + 1
          mac_addr:
            type: mac_addr
            desc: Address to program
      AT+USYEC:
        brief: Error Code
        syntax:
          AT+USYEC?:
            api_name: GetLastErrorCode
            desc: Read the last error code
            responses:
              +USYEC:<error_code>:
                desc: Latest error code
        parameters:
          error_code:
            desc: Error code
            type: integer
      AT+USYEE:
        brief: Extended Error codes on/off
        syntax:
          AT+USYEE=<extended_errors>:
            storable: true
            api_name: SetExtendedError
            desc: Enable or disable extended error codes
          AT+USYEE?:
            api_name: GetExtendedError
            desc: Read extended error codes enabled/disabled
            responses:
              +USYEE:<extended_errors>:
                desc: Extended error codes setting
        parameters:
          extended_errors:
            desc: Extended error codes setting
            type: enumerator
            values:
              off:
                desc: (Factory default) Extended error codes will not be displayed
                value: 0
              on:
                desc: Extended error code will be displayed on every error
                value: 1
      AT+USYUA:
        brief: Upload Alerts
        visibility: hidden
        syntax:
          AT+USYUA:
            desc: Upload alerts to DevAlert
      AT+USYTU:
        brief: Set/Get system time in unix time format
        syntax:
          AT+USYTU=<unix_time>:
            api_name: SetUnixTime
            desc: Set system time of the module.
          AT+USYTU?:
            api_name: GetUnixTime
            desc: Get system time of the module.
            responses:
              +USYTU:<unix_time>:
                desc: Time in Unix time format
        parameters:
          unix_time:
            desc: time as hex string in Unix time format, which is the number of seconds
              since 1970-01-01T00:00:00 (UTC)
            type: byte_array
      ATE:
        brief: Echo On/Off
        desc: This command configures whether or not the module echoes the characters
          received from the host.
        syntax:
          ATE0:
            storable: true
            api_name: SetEchoOff
            desc: Set echo off
          ATE1:
            storable: true
            api_name: SetEchoOn
            desc: Set echo on
          ATE?:
            api_name: GetEcho
            desc: Read current echo setting
            responses:
              <echo_on>:
                desc: Current echo setting
        parameters:
          echo_on:
            type: enumerator
            values:
              off:
                desc: Module does not echo the characters
                value: 0
              on:
                desc: (Factory default) Module echoes the characters
                value: 1
      ATS:
        brief: S-registers
        desc: Used to set different configuration parameters
        syntax:
          ATS2=<escape_char>:
            storable: true
            api_name: SetEscSequenceChar
            desc: Write escape character. This settings change the decimal value of
              the escape character used by some modes, such as transparent mode for
              example, to detect an escape sequence and exit.
          ATS2?:
            api_name: GetEscSequenceChar
            desc: Read escape character
            responses:
              <escape_char>:
                desc: Current escape character
          ATS3=<line_term>:
            storable: true
            api_name: SetLineTermChar
            desc: Write line termination character. This setting changes the decimal
              value of the character recognized by the DCE from the DTE to terminate
              an incoming command line. It is also generated by the DCE as part of
              the header, trailer, and terminator for result codes and information
              text along with the S4 parameter. The previous value of S3 is used to
              determine the command line termination character for entry of the command
              line containing the S3 setting command. However, the result code issued
              shall use the value of S3 as set during the processing of the command
              line. For example, if S3 was previously set to 13 and the command line
              "ATS3=30" is issued, the command line shall be terminated with a CR,
              character (13), but the result code issued will use the character with
              the ordinal value 30 instead of the CR.
          ATS3?:
            api_name: GetLineTermChar
            desc: Read line termination character
            responses:
              <line_term>:
                desc: Current line termination character
          ATS4=<resp_format>:
            storable: true
            api_name: SetRspFormatChar
            desc: Write response format character. This setting changes the decimal
              value of the character generated by the DCE as part of the header, trailer,
              and terminator for result codes and information text, along with the
              S3 parameter. If the value of S4 is changed in a command line, the result
              code issued in response to that command line will use the new value
              of S4.
          ATS4?:
            api_name: GetRspFormatChar
            desc: Read response format character
            responses:
              <resp_format>:
                desc: Current response format character
          ATS5=<backspace>:
            storable: true
            api_name: SetBackspaceChar
            desc: Writes backspace character. This setting changes the decimal value
              of the character recognized by the DCE as a request to delete from the
              command line, the immediately preceding character.
          ATS5?:
            api_name: GetBackspaceChar
            desc: Read backspace character
            responses:
              <backspace>:
                desc: Current backspace character
        parameters:
          line_term:
            type: integer
            desc: 'Command line termination character. Factory default: 13'
            valid_values: 0..127
          resp_format:
            type: integer
            desc: 'Response format character. Factory default: 10'
            valid_values: 0..127
          backspace:
            type: integer
            desc: 'Backspace character. Factory default: 8'
            valid_values: 0..127
          escape_char:
            type: integer
            desc: 'Escape character. Factory default: 43'
            valid_values: 0..127
      AT+UTMES:
        brief: Transparent mode escape sequence settings
        syntax:
          AT+UTMES=<pre_timeout>,<post_timeout>,<escape_timeout>:
            api_name: SetEscSequenceSettings
            desc: Configures the transparent mode escape sequence settings.
          AT+UTMES?:
            api_name: GetEscSequenceSettings
            desc: Reads current transparent mode escape sequence settings.
            responses:
              +UTMES:<pre_timeout>,<post_timeout>,<escape_timeout>:
                desc: Successful read response
        parameters:
          pre_timeout:
            type: integer
            desc: 'Minimum time (ms) of no data activity required before the escape
              sequence is sent. Factory default: 1000'
            valid_values: 50..5000
          post_timeout:
            type: integer
            desc: 'Minimum time (ms) of no data activity required after the escape
              sequence is sent. Factory default: 1000'
            valid_values: 50..5000
          escape_timeout:
            type: integer
            desc: 'Maximum time interval (ms) between escape characters. Factory default:
              200'
            valid_values: 50..5000
  Bluetooth:
    type_prefix: bt
    desc: "Bluetooth commands\n\nNORA-W36 supports up to 3 connections as BLE central\
      \ and 1 as peripheral.\n"
    parameters:
      conn_handle:
        type: integer
        desc: Connection handle of the Bluetooth low energy connection.
      bd_addr:
        type: bd_addr
        desc: Bluetooth device address of the remote device.
      rssi:
        type: integer
        desc: Received signal strength in dBm.
      bond_status:
        desc: Bonding status
        type: enumerator
        values:
          bonding_succeeded:
            value: 0
            desc: Bonding procedure succeeded.
          bonding_failed_timeout:
            value: 1
            desc: Bonding procedure failed due to page timeout.
          bonding_failed_auth:
            value: 2
            desc: Bonding failed because of authentication or pairing failed. This
              could be due to incorrect PIN/passkey.
          bonding_failed_mitm:
            value: 3
            desc: Bonding failed because the protection against Man-In-The-Middle
              attack could not be guaranteed; the generated link key was too weak.
          bonding_failed_peer_lost_bond:
            value: 4
            desc: Bonding failed because peer have lost the bonding info. Use ${ref:AT+UBTUB}
              to delete the local bond to allow re-bonding.
      numeric_value:
        desc: Numeric value.
        type: integer
        valid_values: 0..999999
      confirm:
        type: enumerator
        values:
          no:
            value: 0
            desc: Deny bonding.
          yes:
            value: 1
            desc: Confirm bonding.
      tx_phy:
        type: integer
        desc:
        - 'Requested PHY for Transmitter:'
        - '0: Let other side decide'
        - 'OR a bit field with bits:'
        - 'Bit 0: 1 Mbps preferred'
        - 'Bit 1: 2 Mbps preferred'
        valid_values: 0..3
      rx_phy:
        desc:
        - Requested PHY for Receiver
        - '0: Let other side decide'
        - 'OR a bit field with bits:'
        - 'Bit 0: 1 Mbps preferred'
        - 'Bit 1: 2 Mbps preferred'
        valid_values: 0..3
        type: integer
      phy_status:
        desc: "Bluetooth status codes:\n0: Success\n0x01-0xFF: Error, see Bluetooth\
          \ Core Specifications, Vol 2, Part D.\n"
        type: integer
        valid_values: 0..255
      config_id:
        desc: Configuration id
        type: integer
        valid_values: 200..200
      connect_sps:
        desc: "Should start a SPS connection when ACL link is up. \nInteger Boolean\
          \ flag  0 = No, 1 = Yes\n"
        type: integer
        valid_values: 0..1
      int_dBm:
        type: integer
        desc: TX power level in dBm, integer part.
        valid_values: -20..20
      decimal_dBm:
        type: integer
        desc: TX power level in dBm, decimal part.
        valid_values: 0..99
      device_name:
        type: string
        desc: Name of the discovered device.
      data_type:
        type: enumerator
        desc: Type of advertising data received.
        values:
          scan_response:
            desc: Scan response data.
            value: 0
          advertise_data:
            desc: Advertise data.
            value: 1
      data:
        type: byte_array
        desc: Complete advertise/scan response data received from the remote device.
      discovery_type:
        type: enumerator
        values:
          all:
            desc: All with no filter. Displays all found devices; devices can be displayed
              multiple times.
            value: 0
          all_no_duplicates:
            desc: General inquiry. Displays devices in General or Limited discoverability
              mode; each device is displayed only once.
            value: 1
      discovery_mode:
        type: enumerator
        default: 0
        values:
          active:
            desc: Active discovery.
            value: 0
          passive:
            desc: Passive, no scan response data will be received.
            value: 1
      discovery_length:
        type: integer
        desc: 'Timeout measured in milliseconds. Time range: 10 ms - 40 s'
        valid_values: 10..40000
        default: 5000
    urcs:
      +UEBTC:<conn_handle>,<bd_addr>:
        api_name: Connect
        brief: Event Bluetooth Connected
        desc: Event indicating successful Bluetooth connection.
      +UEBTDC:<conn_handle>:
        api_name: Disconnect
        brief: Event Bluetooth Disconnected
        desc: Event indicating a disconnected Bluetooth connection.
      +UEBTB:<bd_addr>,<bond_status>:
        api_name: BondStatus
        brief: Event Bluetooth Bond status
        desc: Event indicates that a bonding procedure is completed.
      +UEBTUC:<bd_addr>,<numeric_value>:
        api_name: UserConfirmation
        brief: Event Bluetooth User Confirmation
        desc: This event is used while bonding with IO capability DisplayYesNo. This
          event indicates that the user confirmation of a numeric value is required.
      +UEBTUPD:<bd_addr>,<numeric_value>:
        api_name: PasskeyEntry
        brief: Event Bluetooth Passkey entry
        desc: This event is used to indicate to the user that a passkey has to be
          entered on the remote device during a bonding procedure with the IO capability
          DisplayOnly.
      +UEBTUPE:<bd_addr>:
        api_name: PasskeyRequest
        brief: Event Bluetooth Passkey request
        desc: This event is used during bonding with IO capability KeyboardOnly to
          indicate that a passkey is required from the user. User should respond to
          this event with the ${ref:AT+UBTUPE} command.
      +UEBTPHYU:<conn_handle>,<phy_status>,<tx_phy>,<rx_phy>:
        api_name: PhyUpdate
        brief: Event Bluetooth PHY update
        desc: This event informs the result of a PHY update procedure. It may be generated
          as a result of the command ${ref:AT+UBTPHYR} or as a successful event, if
          the operation has been initiated by the remote peer.
      +UEBTBGD:<bd_addr>,<rssi>,<device_name>,<data_type>,<data>:
        api_name: BackgroundDiscovery
        brief: Event Bluetooth Background Discovery
        desc: This event is generated during background discovery when a device is
          found. The format matches ${ref:AT+UBTD} responses.
    commands:
      AT+UBTM:
        brief: Bluetooth Mode
        desc: Set and read Bluetooth Mode.
        syntax:
          AT+UBTM=<mode>:
            api_name: SetMode
            storable: true
            requires_reboot: true
            desc: Set Bluetooth Mode.
          AT+UBTM?:
            api_name: GetMode
            desc: Read Bluetooth Mode.
            responses:
              +UBTM:<mode>:
                desc: Successful read response.
        parameters:
          mode:
            type: mode
      AT+UBTC:
        brief: Bluetooth Connect
        desc: Make an ACL connection to a remote device with defined protocol type.
          Unsolicited events ${ref:+UEBTC} or ${ref:+UEBTDC} will be sent out to confirm
          the connection establishment.
        syntax:
          AT+UBTC=<bd_addr>:
            api_name: Connect
            desc: Initiate connection.
      AT+UBTP:
        brief: Bluetooth Persistent
        syntax:
          AT+UBTP=<bd_addr>,<connect_sps>:
            storable: true
            requires_reboot: true
            desc:
            - Configure an ACL link with automatic re-connection. As opposed to ${ref:AT+UBTC},
              this command will not initiate a connection directly but is used for
              storing a connection configuration persistently so that the link is
              automatically setup on boot.
            - See also ${ref:AT+USOP}
            responses:
              +UBTP:<config_id>:
                desc: Successful write response, returning a configuration id identifying
                  the configuration
      AT+UBTPR:
        brief: Bluetooth Persistent Remove
        desc: Remove a Persistent Bluetooth Connection configuration
        syntax:
          AT+UBTPR=<config_id>:
            storable: true
            desc: Removes a persistent bluetooth connection configuration
            notes: The corresponding link will be automatically disconnected
      AT+UBTPL:
        brief: Bluetooth Persistent List
        desc: List all configured persistent bluetooth connections
        syntax:
          AT+UBTPL?:
            desc: List the currently configured Persistent Bluetooth Connections
            responses:
              +UBTPL:<config_id>,<bd_addr>,<connect_sps>:
                desc: Successful read response
      AT+UBTDC:
        brief: Bluetooth Disconnect
        desc: Used to close an ACL connection.
        syntax:
          AT+UBTDC=<conn_handle>:
            api_name: Disconnect
            desc: Close an existing ACL connection.
      AT+UBTLN:
        brief: Bluetooth Local Name
        desc: Set the BLE local name used in the default scan response data and in
          the Generic Access Profile service.
        syntax:
          AT+UBTLN?:
            api_name: GetLocalName
            desc: Reads the local Bluetooth device name.
            responses:
              +UBTLN:<device_name>:
                desc: Successful read response.
          AT+UBTLN=<device_name>:
            api_name: SetLocalName
            storable: true
            desc: Writes the local Bluetooth device name.
        parameters:
          device_name:
            type: string
            length: 0..29
            desc: Default local name is the MODEL-xxxxxx where xxxxxx are the last
              3 bytes of the device MAC address in hexadecimal format. If the local
              name is set to "" it is cleared but will revert to the default name
              after a restart.
      AT+UBTHCI:
        visibility: hidden
        brief: Bluetooth HCI logging
        desc: Enable HCI logging on the module.
        syntax:
          AT+UBTHCI:
            desc: Enable HCI logging.
      AT+UBTD:
        brief: Bluetooth Discovery
        desc: Performs a discovery procedure to find any advertising devices in the
          vicinity.
        syntax:
          AT+UBTD:
            api_name: DiscoveryDefault
            multiline_response: true
            desc: Start discovery using default parameters
            responses:
              +UBTD:<bd_addr>,<rssi>,<device_name>,<data_type>,<data>:
                desc: This response is sent for every found device. If no name is
                  found, <device_name> is an empty string, if <mode> is set to Active,
                  both Scan responses and Advertisements will be shown.
          AT+UBTD=<discovery_type>[,<discovery_mode>[,<discovery_length>]]:
            api_name: Discovery
            multiline_response: true
            desc: Start discovery.
            responses:
              +UBTD:<bd_addr>,<rssi>,<device_name>,<data_type>,<data>:
                desc: This response is sent for every found device. If no name is
                  found, <device_name> is an empty string, if <mode> is set to Active,
                  both Scan responses and Advertisements will be shown.
      AT+UBTBGD:
        brief: Bluetooth Background Discovery
        desc: Start a background discovery. Use together with ${ref:AT+UBTSS2} to
          connect to directed advertisements during scanning. If only interested in
          connecting to directed advertisements, use ${ref:AT+UBTSS2} together with
          output_events to not output discovery events.
        syntax:
          AT+UBTBGD:
            api_name: BgDiscoveryDefaultStart
            desc: Start background discovery
          AT+UBTBGD=<discovery_type>[,<discovery_mode>[,<output_events>]]:
            api_name: BgDiscoveryStart
            desc: Start background discovery
        parameters:
          output_events:
            type: enumerator
            values:
              disabled:
                value: 0
                desc: Disable output events during background discovery
              enabled:
                value: 1
                desc: Enable output events during background discovery
      AT+UBTBGDS:
        brief: Bluetooth Background Discovery Stop
        desc: Stop background discovery.
        syntax:
          AT+UBTBGDS:
            api_name: BgDiscoveryStop
            desc: Stop background discovery
      AT+UBTRSS:
        brief: Bluetooth RSSI
        desc: Returns the current received RSSI for a specified Bluetooth connection.
        syntax:
          AT+UBTRSS=<conn_handle>:
            api_name: GetRssi
            desc: Returns the current RSSI for a specified Bluetooth connection.
            responses:
              +UBTRSS:<rssi>:
                desc: Successful response.
      AT+UBTCL:
        brief: Bluetooth Connection List
        desc: List all active Bluetooth low energy ACl connections.
        syntax:
          AT+UBTCL:
            api_name: ListConnections
            multiline_response: true
            desc: List all Bluetooth low energy ACL connections.
            responses:
              +UBTCL:<conn_handle>,<bd_addr>:
                desc: Sent for every connection.
      AT+UBTCST:
        brief: Bluetooth Connection Status
        desc: "Read negotiated properties of a Bluetooth low energy ACL connection.\n\
          Some of the properties are a result of negotiation when a connections is\
          \ set up, and this command gives the possibility\nto see what properties\
          \ the connection actually uses.\n"
        syntax:
          AT+UBTCST=<conn_handle>:
            api_name: ListConnectionStatus
            multiline_response: true
            desc: Read all properties of an existing Bluetooth low energy ACL connection.
            responses:
              +UBTCST:<prop_id>,<status_val>:
                desc: One response for each prop_id.
          AT+UBTCST=<conn_handle>,<prop_id>:
            api_name: GetConnectionStatus
            desc: Read a specific property of an existing Bluetooth low energy ACL
              connection.
            responses:
              +UBTCST:<prop_id>,<status_val>:
                at_client_ignore_params:
                - prop_id
                desc: Successful read response.
        parameters:
          status_val:
            type: integer
            desc: Value of the preceding property.
          prop_id:
            type: enumerator
            values:
              connection_interval:
                desc: "Connection interval used on this connection.\n Range: 6 to\
                  \ 3200\n Time = status_val * 1.25 ms\n Time range: 7.5 ms to 4000\
                  \ ms\n"
                value: 0
              peripheral_latency:
                desc: 'Peripheral latency for the connection in number of connection
                  events. Range: 0 to 499'
                value: 1
              supervision_timeout:
                desc: 'Supervision timeout (in ms) for this connections. Range: 100
                  ms to 32000 ms'
                value: 2
              mtu_size:
                desc: MTU size for this connections.
                value: 3
              pdu_tx_payload_length:
                desc: Data Channel TX PDU Payload Length.
                value: 4
              pdu_rx_payload_length:
                desc: Data Channel RX PDU Payload Length.
                value: 5
              data_length_extension:
                desc: 'Data Length Extension state. 0: Data Length Extension Off \
                  1: Data Length Extension On'
                value: 6
              local_role:
                desc: 'Local role in this connection. 1: Low Energy Central \ 2: Low
                  Energy Peripheral'
                value: 7
              tx_phy:
                desc: "TX Phy used in this connection\nBit 0: 1 Mbps\nBit 1: 2 Mbps\n\
                  Bit 2: Coded\n"
                value: 8
              rx_phy:
                desc: "RX Phy used in this connection\nBit 0: 1 Mbps\nBit 1: 2 Mbps\n\
                  Bit 2: Coded\n"
                value: 9
      AT+UBTA:
        brief: Read which advertisements are currently running
        syntax:
          AT+UBTA?:
            api_name: GetAdvertiseInformation
            desc: Read the current advertisements
            responses:
              +UBTA:<legacy_adv>,<directed_adv>,<extended_adv_list>:
                desc: Successful read
        parameters:
          legacy_adv:
            type: enumerator
            values:
              disabled:
                desc: Legacy Advertisement Not Running
                value: 0
              enabled:
                desc: Legacy Advertisement Running
                value: 1
          directed_adv:
            type: enumerator
            values:
              disabled:
                desc: Directed Advertisement Not Running
                value: 0
              enabled:
                desc: Directed Advertisement Running
                value: 1
          extended_adv_list:
            type: int_list
            length: 0..1
            desc: List of indexes currently being used for extended advertisements
      AT+UBTADL:
        brief: Bluetooth Advertisement Data Legacy
        desc:
        - Command for setting custom legacy advertise data in Bluetooth low energy.
          Maximum of 28 bytes.
        - Any custom advertising data will be appended to the default mandatory flags
          field.
        - Note that the AT command ${ref:AT+UBTD} supports scan modes that can be
          used to see the complete advertising data.
        - This is useful when testing the advertise data set with the AT+UBTALD. By
          default, the service UUID for the u-blox Serial Port Service is part of
          the advertising data.
        syntax:
          AT+UBTADL=<adv_data>:
            storable: true
            api_name: SetLegacyAdvertiseData
            desc: Write custom advertising data.
          AT+UBTADL?:
            api_name: GetLegacyAdvertiseData
            desc: Read custom advertising data.
            responses:
              +UBTADL:<adv_data>:
                desc: Successful read response.
        parameters:
          adv_data:
            type: byte_array
            length: 3..28
      AT+UBTADLC:
        brief: Bluetooth Advertising Data Legacy Clear
        desc: Clear the custom advertise data, i.e.use the default value when advertising
        syntax:
          AT+UBTADLC:
            api_name: ClearLegacyAdvertiseData
            desc: Clear the custom legacy advertise data.
      AT+UBTASD:
        brief: Bluetooth Advertisement Scan Data
        desc: Command for setting custom scan response data in Bluetooth low energy.
          Any custom scan response data will override the default scan response data.
          By default, the local name is part of the scan response data.
        syntax:
          AT+UBTASD=<scan_rsp_data>:
            storable: true
            api_name: SetScanResponseData
            desc: Write custom scan response data.
          AT+UBTASD?:
            api_name: GetScanResponseData
            desc: Read custom scan response data.
            responses:
              +UBTASD:<scan_rsp_data>:
                desc: Successful read response.
        parameters:
          scan_rsp_data:
            type: byte_array
            length: 1..31
      AT+UBTASDC:
        brief: Bluetooth Scan Data Clear
        desc: Clear the custom scan response data, i.e. use the default value when
          advertising
        syntax:
          AT+UBTASDC:
            api_name: ClearScanResponseData
            desc: Clear the custom scan response data.
      AT+UBTAL:
        brief: Bluetooth Advertise Legacy Enable
        desc: Start legacy advertisement if not started
        syntax:
          AT+UBTAL:
            storable: true
            api_name: LegacyAdvertisementStart
            desc: Start legacy advertisement if not started.
      AT+UBTALD:
        brief: Bluetooth Advertise Legacy Disable
        desc: Stop legacy advertisement if started
        syntax:
          AT+UBTALD:
            storable: true
            api_name: LegacyAdvertisementStop
            desc: Stop legacy advertisement if started.
      AT+UBTAD:
        brief: Bluetooth Directed Advertisement
        desc: Start a directed advertisement to a given Bluetooth Address
        syntax:
          AT+UBTAD=<bd_addr>[,<timeout>]:
            api_name: DirectedAdvertisementStart
            desc: "Starts directed advertisements to Bluetooth Address.\nBy default\
              \ the timeout is 1280 ms, and uses High Duty Cycle Advertising. A timeout\
              \ greater than this will result in\nLow Duty Cycle Advertising as High\
              \ Duty Cycle Advertising has a limited use of only 1280 ms. Setting\
              \ timeout to 0 will let the\ndevice advertise indefinitely in Low Duty\
              \ Cycle mode.\n"
        parameters:
          timeout:
            type: integer
            desc: Timeout for Directed Advertisements.
            default: 1280
      AT+UBTADD:
        brief: Bluetooth Advertise Directed Disable
        desc: Stop any ongoing directed advertisement
        syntax:
          AT+UBTADD:
            api_name: DirectedAdvertisementStop
            desc: "Stop directed advertisements.\n"
      AT+UBTCS:
        brief: Bluetooth Connection Settings
        desc: Get and set connection related settings
        syntax:
          AT+UBTCS0=<connection_interval_minimum>:
            storable: true
            api_name: SetConnectionIntervalMin
            desc: Write connection interval minimum.
          AT+UBTCS0?:
            api_name: GetConnectionIntervalMin
            desc: Read Connection Interval minium.
            responses:
              +UBTCS0:<connection_interval_minimum>:
                desc: Successful read of connection interval minimum.
          AT+UBTCS1=<connection_interval_maximum>:
            storable: true
            api_name: SetConnectionIntervalMax
            desc: Write connection interval maximum.
          AT+UBTCS1?:
            api_name: GetConnectionIntervalMax
            desc: Read Connection Interval maximum.
            responses:
              +UBTCS1:<connection_interval_maximum>:
                desc: Successful read of connection interval maximum.
          AT+UBTCS2=<connection_peripheral_latency>:
            storable: true
            api_name: SetConnectionPeripheralLatency
            desc: Write connection peripheral latency.
          AT+UBTCS2?:
            api_name: GetConnectionPeripheralLatency
            desc: Read connection peripheral latency.
            responses:
              +UBTCS2:<connection_peripheral_latency>:
                desc: Successful read of connection peripheral latency.
          AT+UBTCS3=<connection_linkloss_timeout>:
            storable: true
            api_name: SetConnectionLinklossTimeout
            desc: Write connection linkloss timeout.
          AT+UBTCS3?:
            api_name: GetConnectionLinklossTimeout
            desc: Read connection linkloss timeout.
            responses:
              +UBTCS3:<connection_linkloss_timeout>:
                desc: Successful read of connection linkloss timeout.
          AT+UBTCS4=<preferred_tx_phy>:
            storable: true
            api_name: SetPreferredTxPhy
            desc: Write Preferred TX PHY.
          AT+UBTCS4?:
            api_name: GetPreferredTxPhy
            desc: Read Preferred TX PHY.
            responses:
              +UBTCS4:<preferred_tx_phy>:
                desc: Successful read of Preferred TX PHY.
          AT+UBTCS5=<preferred_rx_phy>:
            storable: true
            api_name: SetPreferredRxPhy
            desc: Write Preferred RX PHY.
          AT+UBTCS5?:
            api_name: GetPreferredRxPhy
            desc: Read Preferred RX PHY.
            responses:
              +UBTCS5:<preferred_rx_phy>:
                desc: Successful read of Preferred RX PHY.
          AT+UBTCS?:
            desc: Read all Bluetooth Configuration param values.
            responses:
              +UBTCS:<param>,<value>:
                desc: Successful read response for AT+UBTCS.
        parameters:
          connection_interval_minimum:
            desc: "Connection interval minimum (must be <= Connection interval maximum).\
              \ Final results will be a result of negotiation between devices.\n Default:\
              \ 24.\n Calculation: connection_interval_minimum * 1.25. ms"
            type: integer
            valid_values: 6..3200
            default: 24
          connection_interval_maximum:
            desc: "Connection interval maximum (must be >= Connection interval minimum).\
              \ Final results will be a result of negotiation between devices.\n Default:\
              \ 40.\n Calculation: connection_interval_maximum * 1.25 ms."
            type: integer
            valid_values: 6..3200
            default: 40
          connection_peripheral_latency:
            desc: "Connection peripheral latency.\n Default: 0\n Calculation: Number\
              \ of connection events."
            type: integer
            default: 0
            valid_values: 0..500
          connection_linkloss_timeout:
            desc: "Connection linkloss timeout.\n Default: 2000\n Calculation: connection_linkloss_timeout\
              \ ms"
            type: integer
            default: 2000
            valid_values: 100..32000
          preferred_tx_phy:
            desc:
            - Preferred Transmitter PHY
            - '0: Let other side decide'
            - 'OR a bit field with bits:'
            - 'Bit 0: 1 Mbps preferred'
            - 'Bit 1: 2 Mbps preferred'
            valid_values: 0..3
            type: integer
            default: 0
          preferred_rx_phy:
            desc:
            - Preferred PHY for Receiver
            - '0: Let other side decide'
            - 'OR a bit field with bits:'
            - 'Bit 0: 1 Mbps preferred'
            - 'Bit 1: 2 Mbps preferred'
            valid_values: 0..3
            type: integer
            default: 0
          param:
            desc: Connection parameter.
            type: enumerator
            values:
              connection_interval_min:
                desc: Connection interval minimum.
                value: 0
              connection_interval_max:
                desc: Connection interval maximum.
                value: 1
              connection_peripheral_latency:
                desc: Connection peripheral latency.
                value: 2
              connection_linkloss_timeout:
                desc: Connection linkloss timeout.
                value: 3
              preferred_tx_phy:
                desc: Preferred Transmitter PHY
                value: 4
              preferred_rx_phy:
                desc: Preferred Receiver PHY
                value: 5
          value:
            desc: Value of connection parameter.
            type: integer
            valid_values: 0..65535
      AT+UBTALS:
        brief: Bluetooth Advertisement Legacy Settings
        desc: Get and Set Advertisement Legacy Settings.
        syntax:
          AT+UBTALS=<advertisement_interval_minimum>,<advertisement_interval_maximum>:
            api_name: SetLegacyAdvertisementConfig
            desc: Configure advertisement parameters for legacy advertisements
          AT+UBTALS?:
            api_name: GetLegacyAdvertisementConfig
            desc: Read advertisement parameters for legacy advertisements
            responses:
              +UBTALS:<advertisement_interval_minimum>,<advertisement_interval_maximum>:
                desc: Successful read of advertisement configuration.
        parameters:
          advertisement_interval_minimum:
            desc: "Advertising interval minimum (must be <= Advertising interval maximum.\
              \ \n Default: 1600.\n Calculation: advertisement_interval_minimum *\
              \ 0.625 ms)"
            type: integer
            valid_values: 32..16384
            default: 1600
          advertisement_interval_maximum:
            desc: "Advertising interval maximum (must be >= Advertising interval minimum.\
              \ \n Default: 2000.\n Calculation: advertisement_interval_maximum *\
              \ 0.625 ms)"
            type: integer
            valid_values: 32..16384
            default: 2000
      AT+UBTSS:
        brief: Bluetooth Scan Settings
        desc: Get and Set Scan Settings.
        syntax:
          AT+UBTSS0=<scan_interval>:
            api_name: SetScanInterval
            desc: Write scan interval.
          AT+UBTSS0?:
            api_name: GetScanInterval
            desc: Read scan Interval.
            responses:
              +UBTSS0:<scan_interval>:
                desc: Successful read of scan interval.
          AT+UBTSS1=<scan_window>:
            api_name: SetScanWindow
            desc: Write scan window.
          AT+UBTSS1?:
            api_name: GetScanWindow
            desc: Read scan Interval.
            responses:
              +UBTSS1:<scan_window>:
                desc: Successful read of scan window.
          AT+UBTSS?:
            desc: Read all scanning parameter setting values.
            responses:
              +UBTSS:<scan_param>,<value>:
                desc: Successful read response for AT+UBTSS?.
        parameters:
          scan_interval:
            desc: "Scan interval (must be >= Scan window. \n Default: 160.\n Calculation:\
              \ scan_interval * 0.625 ms)"
            type: integer
            valid_values: 16..16384
            default: 160
          scan_window:
            desc: "Scan window (must be <= Scan interval. \n Default: 128.\n Calculation:\
              \ scan_interval * 0.625 ms)"
            type: integer
            valid_values: 16..16384
            default: 128
          value:
            desc: Value of scan parameter.
            type: integer
            valid_values: 0..65535
          scan_param:
            desc: Scan parameter.
            type: enumerator
            values:
              scan_interval:
                desc: Scan interval.
                value: 0
              scan_window:
                desc: Scan window.
                value: 1
      AT+UBTSS2:
        brief: Bluetooth Scan Directed Advertisements
        desc: Configure whether to connect to directed advertisements during scanning.
          This setting is used together with ${ref:AT+UBTBGD} to enable connecting
          to directed advertisements while performing background scanning.
        syntax:
          AT+UBTSS2=<connect_to_directed_adv>:
            storable: true
            api_name: SetConnectToDirectedAdv
            desc: Enable or disable connecting to directed advertisements during scanning.
          AT+UBTSS2?:
            api_name: GetConnectToDirectedAdv
            desc: Read connect to directed advertisements setting.
            responses:
              +UBTSS2:<connect_to_directed_adv>:
                desc: Successful read response.
        parameters:
          connect_to_directed_adv:
            desc: 'Enable (1) or disable (0) connecting to directed advertisements
              during scanning. Default: 0.'
            type: integer
            valid_values: 0..1
            default: 0
      AT+UBTIOC:
        brief: Bluetooth I/O Capabilities
        desc: Set Bluetooth I/O Capabilities, this impacts the possible bonding procedure
          between devices.
        syntax:
          AT+UBTIOC=<io_cap>:
            storable: true
            api_name: SetIoCapabilities
            desc: Set I/O Capabilities
          AT+UBTIOC?:
            api_name: GetIoCapabilities
            desc: Read I/O Capabilities
            responses:
              +UBTIOC:<io_cap>:
                desc: Successful read response for AT+UBTIOC?.
        parameters:
          io_cap:
            default: 0
            type: enumerator
            values:
              no_input_no_output:
                desc: Set I/O Capabilities to No Input No Output.
                value: 0
              display_only:
                desc: Set I/O Capabilities to Display Only.
                value: 1
              display_yes_no:
                desc: Set I/O Capabilities to Display Yes/No
                value: 2
              keyboard_only:
                desc: Set I/O Capabilities to Keyboard Only.
                value: 3
              keyboard_display:
                desc: Set I/O Capabilities to Keyboard Display.
                value: 4
      AT+UBTBSM:
        brief: Bluetooth Bond Security Mode
        desc: "Set the minimum security mode required when bonding. This command works\
          \ together with ${ref:AT+UBTIOC} to determine the bonding procedure used.\n\
          The module will try to use the highest level possible based on the settings\
          \ of this command, ${ref:AT+UBTIOC} and the capabilities of the remote device.\n\
          If the remote device does not support the required security level, the bonding\
          \ procedure will fail.\n"
        syntax:
          AT+UBTBSM=<security_mode>:
            storable: true
            api_name: SetSecurityMode
            desc: Writes the security mode
          AT+UBTBSM?:
            api_name: GetSecurityMode
            desc: Reads the security mode
            responses:
              +UBTBSM:<security_mode>:
                desc: Successful read response for AT+UBTBSM?
        parameters:
          security_mode:
            type: security_mode
      AT+UBTPM:
        brief: Bluetooth Pairing Mode
        desc: Enable or disable pairing.
        syntax:
          AT+UBTPM=<pairing_mode>:
            storable: true
            api_name: SetPairingMode
            desc: Writes the pairing mode.
          AT+UBTPM?:
            api_name: GetPairingMode
            desc: Read current pairing mode.
            responses:
              +UBTPM:<pairing_mode>:
                desc: Successful read response for AT+UBTPM?
        parameters:
          pairing_mode:
            type: enumerator
            default: 0
            values:
              disable:
                desc: Disable pairing mode.
                value: 0
              enable:
                desc: Enable pairing mode.
                value: 1
      AT+UBTUC:
        brief: Bluetooth User Confirmation
        desc: The user confirmation is used together with IO capability DisplayYesNo
          to respond to a user confirmation request (${ref:+UEBTUC}). The command
          shall be used only after ${ref:+UEBTUC} has been received.
        syntax:
          AT+UBTUC=<bd_addr>,<confirm>:
            api_name: UserConfirmation
            desc: Respond to +UEUBTUC and confirm/deny bonding.
      AT+UBTUPE:
        brief: User passkey entry
        desc: The user passkey entry is used together with IO capability KeyboardOnly
          to respond on a user passkey entry request (${ref:+UEBTUPE}). This command
          shall be used only after ${ref:+UEBTUPE} has been received.
        syntax:
          AT+UBTUPE=<bd_addr>,<confirm>[,<passkey>]:
            api_name: UserPasskeyEntry
            desc: Respond to +UEBTUPE event and confirm/deny bonding.
        parameters:
          passkey:
            type: integer
            desc: Passkey used to confirm bonding, if confirm is set to no, this can
              be omitted.
            valid_values: 0..999999
      AT+UBTB:
        brief: Bluetooth Bond
        desc: Performs a GAP bond procedure with another Bluetooth device. For some
          I/O Capabilities, user interaction is required during the bonding procedure.
          The procedure to use is determined by the I/O Capabilities and security
          mode. The maximum number of stored bonds is 20 for NORA-W36.
        syntax:
          AT+UBTB=<bd_addr>:
            api_name: Bond
            desc: Initiate bonding. To perform the bonding, the remote device must
              be in a pairable and connectable mode. Bond Event ${ref:+UEBTB} is generated
              once the bond is complete.
      AT+UBTUB:
        brief: Bluetooth Unbond
        desc: Unbond from a previously bonded device.
        notes: These AT commands will remove the bond from the local device only.
        syntax:
          AT+UBTUB=<bd_addr>:
            api_name: Unbond
            desc: Removes a single previously bonded device.
          AT+UBTUB:
            api_name: UnbondAll
            desc: Removes all previously bonded devices.
      AT+UBTBDL:
        brief: Bluetooth Bonded Devices List
        desc: Reads the list of bonded devices.
        syntax:
          AT+UBTBDL:
            desc: Read list of bonded devices.
            api_name: ListBondedDevices
            multiline_response: true
            responses:
              +UBTBDL:<bd_addr>:
                desc: This response is sent for every found device.
      AT+UBTDIS:
        brief: Bluetooth Device Information Service
        desc: Write and read the module's Device Information Service (DIS) characteristics.
        syntax:
          AT+UBTDIS=<char_id>,<char_value>:
            storable: true
            desc: Set a characteristic value.
            api_name: SetDeviceInfoServiceChar
          AT+UBTDIS=<char_id>:
            desc: Read a characteristic value.
            api_name: GetDeviceInfoServiceChar
            responses:
              +UBTDIS:<char_id>,<char_value>:
                at_client_ignore_params:
                - char_id
                desc: Successful read response.
          AT+UBTDIS?:
            desc: Read all individual characteristic of the Device Information Service
              characteristics.
            api_name: ListDeviceInfoServiceChars
            multiline_response: true
            responses:
              +UBTDIS:<char_id>,<char_value>:
                desc: Successful read response.
        parameters:
          char_id:
            type: enumerator
            values:
              manufacturer_name:
                desc: Manufacturer name string. Maximum length of the custom string
                  is 31 characters.
                value: 0
              model_name:
                desc: Model name string. Maximum length of the custom string is 20
                  characters.
                value: 1
              firmware_revision:
                desc: Firmware revision string. Maximum length of the custom string
                  is 20 characters.
                value: 2
              software_revision:
                desc: Software revision string. Maximum length of the custom string
                  is 20 characters.
                value: 3
          char_value:
            type: string
            desc: Value of Device Information Service characteristic.
      AT+UBTPHYR:
        brief: Bluetooth PHY Request
        desc: "Request a new PHY configuration for a connection. If tx PHY or rx PHY\
          \ is 0, the module will select PHYs\nbased on the peer requirements on that\
          \ specific direction. If the peer does not support the PHY update procedure,\n\
          then the resulting ${ref:+UEBTPHYU} event will have a error status other\
          \ than success.\n"
        syntax:
          AT+UBTPHYR=<conn_handle>,<tx_phy>,<rx_phy>:
            api_name: RequestPhy
            desc: Requests a Bluetooth Low Energy PHY update.
          AT+UBTPHYR=<conn_handle>:
            api_name: GetPhy
            desc: Reads current PHYs for a connection.
            responses:
              +UBTPHYR:<conn_handle>,<tx_phy>,<rx_phy>:
                at_client_ignore_params:
                - conn_handle
                desc: Successful read response.
      AT+UBTMOP:
        brief: Bluetooth Max Output Power
        desc: "Set or read the Bluetooth Max Output Power for all operations including\
          \ advertising, scanning, and connections.\nThe output power is specified\
          \ in dBm.\nThe valid range is from -20 dBm to +20 dBm but the actual supported\
          \ range may vary between different products.\n"
        syntax:
          AT+UBTMOP=<int_dBm>:
            api_name: SetMaxOutputPower
            storable: true
            requires_reboot: true
            desc: Set the Bluetooth Max Output Power level.
          AT+UBTMOP?:
            api_name: GetMaxOutputPower
            desc: "Read current Bluetooth Max Output Power level. Will return error\
              \ if the Bluetooth Max Output Power has not been set\nand the default\
              \ power level is used.\n"
            responses:
              +UBTMOP:<int_dBm>:
                desc: Successful read response.
      AT+UBTMOPC:
        brief: Bluetooth Max Output Power Clear
        desc: "Clear any previously set Bluetooth Max Output Power level, and revert\
          \ to the default Max Output Power level.\n"
        syntax:
          AT+UBTMOPC:
            api_name: ClearMaxOutputPower
            storable: true
            requires_reboot: true
            desc: Clear any previously set max Bluetooth Max Output Power level.
  GATT client:
    desc: GATT Client
    parameters:
      conn_handle:
        type: integer
        desc: Bluetooth Low Energy connection handle.
      value_handle:
        type: integer
        desc: Attribute handle of the characteristic value.
      hex_data:
        type: byte_array
        desc: Characteristic data in hexadecimal form. For example, 070809AABBCC
      uuid:
        type: byte_array
        desc: UUID of attribute. Either 16-bit or 128-bit.
      start_handle:
        type: integer
        desc: Service start handle.
      end_handle:
        type: integer
        desc: Service end handle.
    urcs:
      +UEBTGCN:<conn_handle>,<value_handle>,<hex_data>:
        brief: Event GATT Client Notification
        api_name: Notification
        desc: GATT Client Notification. This event is received when the remote side
          sends a notification.
      +UEBTGCI:<conn_handle>,<value_handle>,<hex_data>:
        brief: Event GATT Client Indication
        api_name: Indication
        desc: GATT Client Indication. This event is received when the remote side
          sends an indication.
    commands:
      AT+UBTGPSD:
        brief: GATT Primary Services Discover
        desc: List all GATT services on the GATT server.
        syntax:
          AT+UBTGPSD=<conn_handle>:
            api_name: DiscoverPrimaryServices
            desc: Discover all primary services on the remote device.
            multiline_response: true
            responses:
              +UBTGPSD:<conn_handle>,<start_handle>,<end_handle>,<uuid>:
                at_client_ignore_params:
                - conn_handle
                desc: This response is sent for each service found.
      AT+UBTGPSDU:
        brief: GATT Primary Services Discover by UUID
        desc: Discovers all primary services by UUID on the remote device.
        syntax:
          AT+UBTGPSDU=<conn_handle>,<uuid>:
            api_name: DiscoverPrimaryServicesByUuid
            desc: Start discovery.
            multiline_response: true
            responses:
              +UBTGPSDU:<conn_handle>,<start_handle>,<end_handle>:
                at_client_ignore_params:
                - conn_handle
                desc: This response is sent for each service found.
      AT+UBTGSCD:
        brief: GATT Service Characteristics Discover
        desc: This command will list all characteristics belonging to a service on
          the GATT server.
        syntax:
          AT+UBTGSCD=<conn_handle>,<start>,<end>:
            desc: Discover all characteristics of a service.
            api_name: DiscoverServiceChars
            multiline_response: true
            responses:
              +UBTGSCD:<conn_handle>,<attr_handle>,<properties>,<value_handle>,<uuid>:
                at_client_ignore_params:
                - conn_handle
                desc: This response is sent for each characteristic found.
        parameters:
          start:
            type: integer
            desc: Service start handle.
          end:
            type: integer
            desc: Service end handle.
          attr_handle:
            type: integer
            desc: Attribute handle of the characteristic
          properties:
            type: byte_array
            desc: Bit mask describing the properties of the characteristic
      AT+UBTGCDD:
        brief: GATT Characteristic Descriptors Discover
        desc: Discover Characteristics Descriptors. This command will list all descriptors
          of a characteristic on the GATT server.
        syntax:
          AT+UBTGCDD=<conn_handle>,<value_handle>,<char_end_handle>:
            api_name: DiscoverCharDescriptors
            desc: Discover all descriptors of a characteristic.
            multiline_response: true
            responses:
              +UBTGCDD:<conn_handle>,<char_handle>,<desc_handle>,<uuid>:
                at_client_ignore_params:
                - conn_handle
                desc: This response is sent for each descriptor found.
        parameters:
          char_handle:
            type: integer
            desc: Characteristic handle.
          char_end_handle:
            type: integer
            desc: End handle of characteristic to which descriptor discovery is being
              performed.
          desc_handle:
            type: integer
            desc: Descriptor handle.
      AT+UBTGR:
        brief: GATT Read
        desc: Read a characteristic value.
        syntax:
          AT+UBTGR=<conn_handle>,<value_handle>:
            api_name: Read
            desc: Reads the characteristic; all bytes included.
            responses:
              +UBTGR:<conn_handle>,<value_handle>,<hex_data>:
                at_client_ignore_params:
                - conn_handle
                - value_handle
                desc: Successful read response.
      AT+UBTGRU:
        brief: GATT Read characteristic by UUID
        desc: Read GATT characteristic values by UUID.
        syntax:
          AT+UBTGRU=<conn_handle>,<start>,<end>,<uuid>:
            api_name: ReadByUuid
            desc: Read all the characteristics by UUID. It will read all the bytes
              in each characteristic.
            responses:
              +UBTGRU:<conn_handle>,<value_handle>,<hex_data>:
                at_client_ignore_params:
                - conn_handle
                desc: Successful read response.
        parameters:
          start:
            type: integer
            desc: Start handle.
          end:
            type: integer
            desc: End handle.
      AT+UBTGW:
        brief: GATT Write
        desc: Write a characteristic value.
        syntax:
          AT+UBTGW=<conn_handle>,<value_handle>,<hex_data>:
            api_name: Write
            desc: Write the characteristic value.
      AT+UBTGCCW:
        brief: GATT Client Configuration Write
        desc: Write characteristic configuration to enable notifications or indications.
        syntax:
          AT+UBTGCCW=<conn_handle>,<desc_handle>,<config>:
            api_name: ConfigWrite
            desc: Writes the client characteristic configuration.
        parameters:
          desc_handle:
            type: integer
            desc: Descriptor handle.
          config:
            type: enumerator
            values:
              none:
                value: 0
                desc: None
              enable_notifications:
                value: 1
                desc: Enable notifications
              enable_indications:
                value: 2
                desc: Enable indications
              enable_not_ind:
                value: 3
                desc: Enable notifications and indications
      AT+UBTGWNR:
        brief: GATT Write with No Response
        desc: Write the characteristic with no response message from the remote side.
        syntax:
          AT+UBTGWNR=<conn_handle>,<value_handle>,<hex_data>:
            api_name: WriteNoRsp
            desc: Write characteristic.
      AT+UBTGWL:
        brief: GATT Write long
        desc: Write a long characteristic.
        syntax:
          AT+UBTGWL=<conn_handle>,<value_handle>,<hex_data>,<reliable>,<flag>,<offset>:
            api_name: WriteLong
            desc: Write long characteristic.
        parameters:
          reliable:
            type: enumerator
            values:
              no:
                value: 0
                desc: Not reliable
              yes:
                value: 1
                desc: Reliable
          flag:
            type: enumerator
            values:
              final_data:
                value: 0
                desc: Final data
              more_data:
                value: 1
                desc: More data
              cancel:
                value: 2
                desc: Cancel data writing
          offset:
            type: integer
  GATT Server:
    desc: GATT Server
    parameters:
      read_security:
        type: enumerator
        values:
          none:
            value: 1
            desc: No encryption required.
          unauthenticated:
            value: 2
            desc: Unauthenticated encryption required.
          authenticated:
            value: 3
            desc: Authenticated encryption required.
      properties:
        type: byte_array
        desc: "Property value (a bit field):\nBroadcast: 0x01 - If set, it allows\
          \ broadcasts of the Characteristic Value using Characteristic Configuration\
          \ Descriptor.\nRead: 0x02 - If set, it allows reads of the Characteristic\
          \ Value.\nWrite Without Response: 0x04 - If set, it allows writing of the\
          \ Characteristic Value without response.\nWrite: 0x08 - If set, it allows\
          \ writing of the Characteristic Value with response.\nNotify: 0x10 - If\
          \ set, it allows notifications of a characteristic value.\nIndicate: 0x20\
          \ - If set, it allows indication of a characteristic value with acknowledgement.\n\
          Authenticated Signed Writes: 0x40 - If set, it allows signed writes to the\
          \ characteristic value.\nReserved Bit: 0x80 - Do not use. Reserved for future\
          \ use.\n"
        length: 1..1
      write_security:
        type: enumerator
        values:
          none:
            value: 1
            desc: No encryption required.
          unauthenticated:
            value: 2
            desc: Unauthenticated encryption required.
          authenticated:
            value: 3
            desc: Authenticated encryption required.
    urcs:
      +UEBTGCW:<conn_handle>,<value_handle>,<value>,<options>:
        brief: Event GATT Server Write
        api_name: Notification
        desc: Unsolicited response code for GATT Server. This event occurs when a
          remote client writes to an attribute.
        parameters:
          conn_handle:
            type: integer
            desc: GAP connection handle.
          value_handle:
            type: integer
            desc: Characteristic value handle.
          value:
            type: byte_array
            desc: The data as hex string. For example, 070809AABBCC
          options:
            type: enumerator
            values:
              write_with_out_response:
                value: 0
                desc: Write without Response performed
              write_with_response:
                value: 1
                desc: Write with Response performed
              write_long:
                value: 2
                desc: Write long performed
      +UEBTGRR:<conn_handle>,<value_handle>:
        brief: Event GATT Server Read Response
        api_name: ReadAttribute
        desc: Unsolicited response code for GATT Server. This event occurs when a
          remote client reads an attribute over the air. The event should be responded
          with ${ref:AT+UBTGRRR}.
        parameters:
          conn_handle:
            type: integer
            desc: Handle of the connected device.
          value_handle:
            type: integer
            desc: Handle of the characteristic value.
      +UEBTGIC:<conn_handle>,<char_handle>:
        brief: Event GATT Server Indication Confirmation
        api_name: IndicationAck
        desc: Unsolicited response code for GATT Server. This event occurs when a
          remote GATT client acknowledges the receipt of an indication message sent
          using ${ref:AT+UBTGIS}.
        parameters:
          conn_handle:
            type: integer
            desc: Connected device handle.
          char_handle:
            type: integer
            desc: Characteristic value handle.
    commands:
      AT+UBTGS:
        brief: GATT Service define
        desc: Command to define a GATT service according to a 16-bit Service Assigned
          Number from Bluetooth SIG or a 128-bit user defined service number.
        syntax:
          AT+UBTGS=<uuid>:
            api_name: ServiceDefine
            desc: Defines a service.
            responses:
              +UBTGS:<ser_handle>:
                desc: Successful write response.
        parameters:
          uuid:
            type: byte_array
            desc: UUID of service. This can be either 16 bit or 128 bit.
          ser_handle:
            type: integer
            desc: Handle of the created service.
      AT+UBTGC:
        brief: GATT Characteristic define
        desc: Command to add a GATT characteristic to the most recent GATT service
          record created with ${ref:AT+UBTGS}.
        syntax:
          AT+UBTGC=<uuid>,<properties>,<read_security>,<write_security>,<value>[,<max_length>]:
            api_name: CharDefine
            desc: Create a new characteristic in the GATT table for a GATT server.
              The CCCD for the characteristic, if applicable, is created here. Extended
              properties such as CPFD, CUDD, and SCCD are not supported.
            responses:
              +UBTGC:<value_handle>,<cccd_handle>:
                desc: Successful write response.
        parameters:
          uuid:
            type: byte_array
            desc: UUID of characteristic. This can be either 16 bit or 128 bit.
          value:
            type: byte_array
            desc: Default characteristic value before any value is pushed to it. A
              characteristic value can be 244 bytes long.
          max_length:
            type: integer
            desc: Maximum length of the characteristic in bytes. The maximum value
              is 244 bytes.
            valid_values: 1..244
          value_handle:
            type: integer
            desc: Added characteristic handle.
          cccd_handle:
            type: integer
            desc: CCCD characteristic handle. This value is zero if there is no CCCD.
      AT+UBTGHCC:
        brief: GATT Host Controlled Characteristic
        desc: Create a new host controlled characteristic in the GATT table for a
          GATT server. The CCCD for the characteristic, if applicable, is created
          here. Extended properties such as CPFD, CUDD, and SCCD are not supported.
        syntax:
          AT+UBTGHCC=<uuid>,<properties>,<read_security>,<write_security>:
            api_name: HostCharDefine
            desc: Define a characteristic.
            responses:
              +UBTGHCC:<value_handle>,<cccd_handle>:
                desc: Successful write response.
        parameters:
          uuid:
            type: byte_array
            desc: UUID of characteristic. This can be either 16 bit or 128 bit.
          value_handle:
            type: integer
            desc: Value handle of the added characteristic.
          cccd_handle:
            type: integer
            desc: Client Characteristic Configuration Descriptor (CCCD) handle of
              the added characteristic. This value is zero if there is no CCCD.
      AT+UBTGD:
        brief: GATT Descriptor define
        desc: Define a vendor defined descriptor. Standard Bluetooth low energy descriptors
          such as CCCD are created while creating the characteristic in ${ref:AT+UBTGC}
          command.
        syntax:
          AT+UBTGD=<uuid>,<read_security>,<write_security>,<value>[,<max_length>]:
            api_name: DescriptorDefine
            desc: Define descriptor.
            responses:
              +UBTGD:<desc_handle>:
                desc: Successful write response.
        parameters:
          uuid:
            type: byte_array
            desc: UUID of characteristic. This can be either 16 bit or 128 bit.
          value:
            type: byte_array
            desc: Descriptor value. This can be 23 bytes long.
          max_length:
            type: integer
            desc: Maximum length of the descriptor in bytes. The maximum value is
              23 bytes.
            valid_values: 1..23
          desc_handle:
            type: integer
            desc: Handle of the created descriptor.
      AT+UBTGSA:
        brief: GATT Service Activate
        desc: Activate the service defined with the ${ref:AT+UBTGS} command. After
          this command is issued, it is not possible to add more characteristics or
          descriptors to the service.
        syntax:
          AT+UBTGSA:
            api_name: ServiceActivate
            desc: Activate current defined service.
      AT+UBTGRRR:
        brief: GATT Read Request Respond
        desc: Respond to an unsolicited request to read (see ${ref:+UEBTGRR}) from
          a remote GATT client.
        syntax:
          AT+UBTGRRR=<conn_handle>,<value>:
            api_name: ReadReqResponse
            desc: Responds to read request.
        parameters:
          conn_handle:
            type: integer
            desc: GAP handle of the connected device.
          value:
            type: byte_array
            desc: Characteristic value. This can be 244 bytes long.
      AT+UBTGNS:
        brief: GATT Notification Send
        desc: Send notifications to a remote client. This also updates the value of
          the characteristic.
        syntax:
          AT+UBTGNS=<conn_handle>,<char_handle>,<value>:
            api_name: SendNotification
            desc: Send notification
        parameters:
          conn_handle:
            type: integer
            desc: GAP handle of the connected device.
          char_handle:
            type: integer
            desc: Characteristic value handle.
          value:
            type: byte_array
            desc: Characteristic value. The maximum length is the current MTU size
              - 3.
      AT+UBTGIS:
        brief: GATT Indication Send
        desc: Send indication to a remote client. This also updates the value of the
          characteristic.
        syntax:
          AT+UBTGIS=<conn_handle>,<char_handle>,<value>:
            api_name: SendIndication
            desc: Send notification
        parameters:
          conn_handle:
            type: integer
            desc: GAP handle of the connected device.
          char_handle:
            type: integer
            desc: Characteristic value handle.
          value:
            type: byte_array
            desc: Characteristic value. The maximum length is the current MTU size
              - 3.
      AT+UBTGAV:
        brief: GATT Attribute Value
        desc: Update the value of an attribute. In case of characteristics which allow
          indications and notifications, this command will update the value without
          sending any indications or notifications to the remote side.
        syntax:
          AT+UBTGAV=<attr_handle>,<value>:
            api_name: SetAttrValue
            desc: Set attribute value.
        parameters:
          attr_handle:
            type: integer
            desc: Attribute handle.
          value:
            type: byte_array
            desc: Characteristic value. This can be 244 bytes long.
      AT+UBTGRRRE:
        brief: GATT Read Request Respond with error code
        desc: Respond to read request with application error code.
        syntax:
          AT+UBTGRRRE=<conn_handle>,<error_code>:
            api_name: ReadReqError
            desc: Respond with error code.
        parameters:
          conn_handle:
            type: integer
            desc: GAP handle of connected device.
          error_code:
            type: byte_array
            length: 1..1
            desc: 'Application error code. Allowed value range: 0x80-0x9F'
      AT+UBTGWRE:
        brief: GATT Write Respond with Error code
        desc: Respond to write operation with application error code.
        syntax:
          AT+UBTGWRE=<conn_handle>,<error_code>:
            api_name: WriteReqError
            desc: Respond with error code.
        parameters:
          conn_handle:
            type: integer
            desc: GAP handle of connected device.
          error_code:
            type: byte_array
            length: 1..1
            desc: 'Application error code. Allowed value range: 0x80-0x9F'
      AT+UBTGWRR:
        brief: GATT Write Request Respond
        desc: Accept write request from GATT client.
        syntax:
          AT+UBTGWRR=<conn_handle>:
            api_name: WriteReqResponse
            desc: Respond to write request.
        parameters:
          conn_handle:
            type: integer
            desc: GAP handle of connected device.
      AT+UBTGSCI:
        brief: GATT Service Changed Indication
        desc: Sends an indication to the remote peer client that the attribute table
          of the local GATT server has changed.
        syntax:
          AT+UBTGSCI=<conn_handle>,<start_handle>,<end_handle>:
            api_name: SendServiceChangedInd
            desc: Send Service Changed Indication.
        parameters:
          conn_handle:
            type: integer
            desc: GAP handle of connected device.
          start_handle:
            type: integer
            desc: Start of the affected attribute handle range.
          end_handle:
            type: integer
            desc: End of the affected attribute handle range.
  SPS:
    desc: SPS - Serial Port Service
    parameters:
      conn_handle:
        type: integer
        desc: Connection handle of remote peer
      string_data:
        type: string
        desc: SPS data in string format
        null_terminated: false
      size:
        type: integer
        desc: SPS data size
      written_length:
        type: integer
        desc: Data length that was written.
    urcs:
      +UESPSC:<conn_handle>:
        api_name: Connect
        brief: Event SPS Connection
        desc: Event response for SPS Connect. Upon a successful SPS connection, conn_handle
          will contain the connection handle of the remote peer.
      +UESPSDC:<conn_handle>:
        api_name: Disconnect
        brief: Event SPS Disconnection
        desc: Event response for SPS Connect. Upon a SPS disconnection, conn_handle
          will contain the connection handle of the remote peer.
      +UESPSDS:<conn_handle>,<string_data>:
        output_payload: string
        brief: Event SPS Data String
        desc: Unsolicited event containing SPS data as a string received from remote
          peer.
      +UESPSDB:<conn_handle>{binary_data}:
        output_payload: binary
        brief: Event SPS Data Binary
        desc: Unsolicited event containing SPS data in binary format.
        parameters:
          binary_data:
            type: binary
            desc: The received data.
      +UESPSDA:<conn_handle>,<number_bytes>:
        api_name: DataAvailable
        brief: Event SPS Data Available
        desc: Unsolicited event containing the number of received bytes to read.
        parameters:
          number_bytes:
            type: integer
            desc: Number of bytes available to read.
    commands:
      AT+USPSC:
        brief: SPS Connect
        desc: SPS connect on connected Bluetooth device
        syntax:
          AT+USPSC=<conn_handle>[,<flow_control>]:
            api_name: Connect
            desc: SPS connect on connected Bluetooth device
        parameters:
          conn_handle:
            type: integer
            desc: Connection handle of remote peer
          flow_control:
            type: integer
            desc: 'Flow control: 0 - no flow control, 1 - flow control'
      AT+USPS:
        brief: SPS - Enable/Disable Service
        desc: Enable or disable the SPS service. SPS Service will use the security
          mode set in ${ref:AT+UBTBSM}
        syntax:
          AT+USPS=<service_option>:
            api_name: SetServiceEnable
            desc: Enables or disable the SPS Service.
            storable: true
          AT+USPS?:
            api_name: GetServiceEnable
            desc: Read if the SPS service is enabled or disabled.
            responses:
              +USPS:<service_option>:
                desc: Successful read response.
        parameters:
          service_option:
            type: enumerator
            values:
              disable:
                value: 0
                desc: This option disables the SPS service after saving the configuration
                  and restarting the device. (Default)
              enable:
                value: 1
                desc: "This option enables the SPS service directly.\nIf this option\
                  \ is set, and the configuration is saved,\nSPS will be enabled after\
                  \ reboot.\n"
      AT+USPSPUMP:
        visibility: hidden
        brief: SPS Data pump
        desc: Starts a datapump with 244 bytes to remote peer. If called while datapump
          is enabled, the datapump on the given connection handle will stop.
        syntax:
          AT+USPSPUMP=<conn_handle>:
            desc: Enable SPS datapump
        parameters:
          conn_handle:
            type: integer
            desc: Connection handle of remote peer
      AT+USPSWS:
        brief: SPS Write String
        desc: Write to a peer through SPS
        input_payload: string
        syntax:
          AT+USPSWS=<conn_handle>,<string_data>:
            desc: Write SPS data
            responses:
              +USPSWS:<conn_handle>,<written_length>:
                at_client_ignore_params:
                - conn_handle
                desc: Successful write response
        parameters:
          conn_handle:
            type: integer
            desc: Connection handle of remote peer which has SPS enabled
          string_data:
            type: string
            desc: Data encoded as ascii chars.
            null_terminated: false
            length: 1..1000
      AT+USPSWB:
        input_payload: binary
        brief: SPS Write Binary
        syntax:
          AT+USPSWB=<conn_handle>{binary_data}:
            api_name: Write
            desc: "Writes the specified amount of data to the specified SPS connection\
              \ in binary mode. Max 1000 bytes.\n"
            responses:
              +USPSWB:<conn_handle>,<written_length>:
                at_client_ignore_params:
                - conn_handle
                at_client_return_param: written_length
                desc: Successful write response
        parameters:
          conn_handle:
            type: integer
            desc: Connection handle of remote peer which has SPS enabled
          binary_data:
            type: binary
            desc: The data to write.
      AT+USPSRM:
        brief: SPS Receive Mode
        syntax:
          AT+USPSRM=<read_mode>:
            storable: true
            api_name: SetDataMode
            desc: Set the mode in which to receive SPS data in AT mode.
          AT+USPSRM?:
            api_name: GetDataMode
            desc: Read mode set.
            responses:
              +USPSRM:<read_mode>:
                desc: Successful read response.
        parameters:
          read_mode:
            type: read_mode
      AT+USPSRS:
        brief: SPS Read String
        output_payload: string
        syntax:
          AT+USPSRS=<conn_handle>,<length>:
            desc: "Reads the specified amount of data from given connection handle.\n\
              Note that the data should include no null terminator characters.\n"
            responses:
              +USPSRS:<conn_handle>,<length>,<string_data>:
                at_client_ignore_params:
                - conn_handle
                desc: Successful read response.
        parameters:
          length:
            type: integer
            desc: Data bytes to read.
            valid_values: 0..1000
      AT+USPSRB:
        brief: SPS Read Binary
        output_payload: binary
        syntax:
          AT+USPSRB=<conn_handle>,<length>:
            api_name: Read
            bin_out_length_param: length
            desc: "Reads the specified amount of data from the specified connection\
              \ handle in binary mode.\n"
            responses:
              +USPSRB:<conn_handle>{binary_data}:
                at_client_ignore_params:
                - conn_handle
                desc: Successful read response.
        parameters:
          length:
            type: integer
            desc: Data bytes to read.
            valid_values: 0..1000
          binary_data:
            type: binary
            desc: The available data. Please note that the number of bytes may be
              less than requested.
  Wi-Fi:
    parameters:
      channel:
        desc: Channel
        type: integer
      passphrase:
        desc: Passphrase to use
        type: string
        length: 8..63
      wpa_version:
        type: enumerator
        default: WPA 2
        values:
          wpa2:
            desc: WPA 2
            value: 0
      bssid:
        desc: BSSID of the connected access point
        type: mac_addr
      mac:
        desc: MAC address of the connected Wi-Fi Station
        type: mac_addr
      ip_addr:
        default: 0.0.0.0
        type: ip_addr
        desc: Static IPv4 address
      subnet_mask:
        default: 0.0.0.0
        type: ip_addr
        desc: Subnet mask
      gateway:
        default: 0.0.0.0
        type: ip_addr
        desc: IPv4 gateway address
      prim_dns:
        default: 0.0.0.0
        type: ip_addr
        desc: IPv4 primary dns address
      sec_dns:
        default: 0.0.0.0
        type: ip_addr
        desc: IPv4 secondary dns address
      net_status_id:
        type: enumerator
        values:
          ipv4:
            desc: "The current IPv4 address.\nNote: If network is down this will be\
              \ 0.0.0.0 regardless of IP setting\n"
            value: 0
          subnet:
            desc: "The current subnet mask\nNote: If network is down this will be\
              \ 0.0.0.0 regardless of IP setting\n"
            value: 1
          gate_way:
            desc: "The current gateway\nNote: If network is down this will be 0.0.0.0\
              \ regardless of IP setting\n"
            value: 2
          prim_dns:
            desc: "The current primary DNS server\nNote: If network is down this will\
              \ be 0.0.0.0 regardless of IP setting\n"
            value: 3
          sec_dns:
            desc: "The current secondary DNS server\nNote: If network is down this\
              \ will be 0.0.0.0 regardless of IP setting\n"
            value: 4
          ipv6:
            desc: "The current IPv6 link local address\nNote: If network is down this\
              \ will be [0000:0000:0000:0000:0000:0000:0000:0000] regardless of IP\
              \ setting\n"
            value: 5
      net_status_val:
        type: ip_addr
        desc: IP address
      int_dBm:
        type: integer
        desc: TX power level in dBm, integer part.
        valid_values: -10..40
      decimal_dBm:
        type: integer
        desc: TX power level in dBm, decimal part.
        valid_values: 0..99
    desc: Wi-Fi Commands
    urcs:
      +UEWLU:<wlan_handle>,<bssid>,<channel>:
        brief: Event Wi-Fi Link Up
        desc: This event is sent when Wi-Fi Link goes up
        api_name: LinkUp
        parameters:
          wlan_handle:
            type: wlan_handle
          channel:
            desc: Connected channel
            type: integer
      +UEWLD:<wlan_handle>,<reason>:
        brief: Event Wi-Fi Link Down
        api_name: LinkDown
        desc: This event is sent when Wi-Fi Link goes down
        parameters:
          wlan_handle:
            type: wlan_handle
          reason:
            desc: Standard 802.11 reason codes
            type: integer
      +UEWSNU:
        brief: Event Wi-Fi Station Network Up
        api_name: StationNetworkUp
        desc: This event is sent when Wi-Fi Station network is up
      +UEWSND:
        brief: Event Wi-Fi Station Network Down
        api_name: StationNetworkDown
        desc: This event is sent when Wi-Fi Station network is down
      +UEWSRSI:
        brief: Event Wi-Fi Station Roaming Switch Initiated
        api_name: StationRoamingSwitchInitiated
        desc: This event is sent during Wi-Fi Station Roaming when AP switch is initiated
      +UEWSRSF:
        brief: Event Wi-Fi Station Roaming Switch Failed
        api_name: StationRoamingSwitchFailed
        desc: This event is sent during Wi-Fi Station Roaming when the switch to the
          new AP failed. After this event the module will try to reconnect to the
          configured SSID
      +UEWSRSC:<wlan_handle>,<bssid>,<channel>:
        brief: Event Wi-Fi Station Roaming Switch Completed
        api_name: StationRoamingSwitchCompleted
        desc: This event is sent during Wi-Fi Station Roaming when AP switch is completed
        parameters:
          wlan_handle:
            type: wlan_handle
          channel:
            desc: Connected channel
            type: integer
      +UEWAPNU:
        brief: Event Wi-Fi Access Point Network Up
        api_name: ApNetworkUp
        desc: This event is sent when Wi-Fi Access Point network is up
      +UEWAPND:
        brief: Event Wi-Fi Access Point Network Down
        api_name: ApNetworkDown
        desc: This event is sent when Wi-Fi Access Point network is down
      +UEWAPU:
        brief: Event Wi-Fi Access Point Up
        api_name: ApUp
        desc: This event is sent when Wi-Fi Access Point is started
      +UEWAPD:
        brief: Event Wi-Fi Access Point Down
        api_name: ApDown
        desc: This event is sent when Wi-Fi Access Point is stopped
      +UEWAPSA:<mac>:
        brief: Event Wi-Fi Access Point Station Associated
        api_name: ApStationAssociated
        desc: This event is sent when a Wi-Fi station has associated with the Wi-Fi
          Access point
        parameters:
          mac:
            desc: Mac address of the connected Wi-Fi station
            type: mac_addr
      +UEWAPSDA:<mac>:
        brief: Event Wi-Fi Access Point Station Disassociated
        api_name: ApStationDisassociated
        desc: This event is sent when a Wi-Fi station has disassociated with the Wi-Fi
          Access point
        parameters:
          mac:
            desc: MAC address of the connected Wi-Fi station
            type: mac_addr
    commands:
      AT+UWHN:
        brief: Wi-Fi Host Name
        desc: Set hostname for Wi-Fi interfaces. Note that AP and Station will both
          use the stored hostname
        syntax:
          AT+UWHN=<host_name>:
            storable: true
            api_name: SetHostname
            desc: Set the Host Name
          AT+UWHN?:
            api_name: GetHostname
            desc: Reads the current hostname
            responses:
              +UWHN:<host_name>:
                desc: Successful read response
        parameters:
          host_name:
            type: string
            length: 0..40
            default: "NORA-W36-xxxxxxxxxxxx where xxxxxxxxxxxx is the Wi-Fi station\
              \ mac address\nIf the hostname is set to \"\" it will be restored to\
              \ the factory value after reset\n"
      AT+UWSSE:
        brief: Wi-Fi Station Enterprise security
        desc: Configure enterprise security. Certificates must be uploaded to the
          module before being used in this command, see ${ref:AT+USECUB}
        syntax:
          AT+UWSSE=<wlan_handle>,<ca_name>,<client_cert_name>,<client_key_name>[,<identity>]:
            storable: true
            desc: Set the EAP-TLS connection parameters to use. (DEPRECATED - Use
              the version with tls_version parameter instead)
          AT+UWSSE=<wlan_handle>,<tls_version>,<ca_name>,<client_cert_name>,<client_key_name>[,<identity>]:
            storable: true
            api_name: StationSetSecurityEnterprise
            desc: Set the EAP-TLS connection parameters to use.
        parameters:
          wlan_handle:
            type: wlan_handle
          tls_version:
            type: tls_version
          ca_name:
            type: ca_name
          client_cert_name:
            type: client_cert_name
          client_key_name:
            type: client_key_name
          identity:
            type: identity
      AT+UWSS:
        brief: Wi-Fi Security Config
        desc: Read the current security parameter configuration, for Wi-Fi station
        syntax:
          AT+UWSS=<wlan_handle>:
            api_name: StationGetSecurity
            response_syntax_param: security_mode
            desc: Get the current Wi-Fi station security config
            responses:
              +UWSS:<wlan_handle>,<security_mode>,<wpa_threshold>:
                response_syntax_values:
                - 1
                at_client_ignore_params:
                - wlan_handle
                desc: Response if security mode is WPA
              +UWSS:<wlan_handle>,<security_mode>:
                response_syntax_values:
                - 0
                at_client_ignore_params:
                - wlan_handle
                desc: Response if security mode is Open
              +UWSS:<wlan_handle>,<security_mode>,<ca_name>,<client_cert_name>,<client_key_name>,<identity>:
                response_syntax_values:
                - -1
                at_client_ignore_params:
                - wlan_handle
                desc: "Response if security mode is EAP-TLS. Emitted when security\
                  \ was configured\nusing AT+UWSSE without <tls_version> (DEPRECATED).\
                  \ Prefer configuring with\n<tls_version> so that the +UWSS variant\
                  \ including <tls_version> is emitted instead\n"
              +UWSS:<wlan_handle>,<security_mode>,<tls_version>,<ca_name>,<client_cert_name>,<client_key_name>,<identity>:
                response_syntax_values:
                - 2
                at_client_ignore_params:
                - wlan_handle
                desc: "Response if security mode is EAP-TLS\n"
              +UWSS:<wlan_handle>,<security_mode>,<username>,<ca_name>:
                response_syntax_values:
                - -2
                at_client_ignore_params:
                - wlan_handle
                desc: "Response if security mode is PEAP. Emitted when security was\
                  \ configured\nusing AT+UWSSP without <tls_version> (DEPRECATED).\
                  \ Prefer configuring with\n<tls_version> so that the +UWSS variant\
                  \ including <tls_version> is emitted instead\n"
              +UWSS:<wlan_handle>,<security_mode>,<tls_version>,<username>,<ca_name>:
                response_syntax_values:
                - 3
                at_client_ignore_params:
                - wlan_handle
                desc: "Response if security mode is PEAP\n"
        parameters:
          wlan_handle:
            type: wlan_handle
          security_mode:
            type: security_mode
          wpa_threshold:
            type: wpa_threshold
          tls_version:
            type: tls_version
          ca_name:
            type: ca_name
          client_cert_name:
            type: client_cert_name
          client_key_name:
            type: client_key_name
          username:
            type: username
          identity:
            type: identity
      AT+UWSSP:
        brief: Wi-Fi Station PEAP security
        desc: Configure PEAP security. CA certificate must be uploaded first if used
          here, see ${ref:AT+USECUB}
        syntax:
          AT+UWSSP=<wlan_handle>,<peap_user>,<peap_password>[,<ca_name>]:
            storable: true
            desc: Set the PEAP connection parameters to use. (DEPRECATED - Use the
              version with tls_version parameter instead)
          AT+UWSSP=<wlan_handle>,<tls_version>,<peap_user>,<peap_password>[,<ca_name>]:
            storable: true
            api_name: StationSetSecurityPeap
            desc: Set the PEAP connection parameters to use.
        parameters:
          wlan_handle:
            type: wlan_handle
          tls_version:
            type: tls_version
          peap_user:
            desc: "User name for PEAP authentication. Could be either only username\
              \ or username@domain. Use @ as separator\n"
            type: string
            length: 1..31
          peap_password:
            desc: Password for PEAP authentication.
            type: string
            length: 1..31
          ca_name:
            type: ca_name
      AT+UWSSW:
        brief: Wi-Fi Station Security WPA
        desc: Configure WPA security
        syntax:
          AT+UWSSW=<wlan_handle>,<passphrase>,<wpa_threshold>:
            storable: true
            api_name: StationSetSecurityWpa
            desc: Set WPA connection parameters to use
        parameters:
          wlan_handle:
            type: wlan_handle
          passphrase:
            type: string
            length: 8..63
            desc: Passphrase to use for WPA connection
          wpa_threshold:
            type: wpa_threshold
      AT+UWSSO:
        brief: Wi-Fi Station Security Open
        desc: Configure open security
        syntax:
          AT+UWSSO=<wlan_handle>:
            storable: true
            api_name: StationSetSecurityOpen
            desc: Sets security to open security
        parameters:
          wlan_handle:
            type: wlan_handle
      AT+UWSCP:
        brief: Wi-Fi Station Connection Parameters
        syntax:
          AT+UWSCP=<wlan_handle>,<ssid>:
            storable: true
            api_name: StationSetConnectionParams
            desc: Sets the connection parameters for the connection.
          AT+UWSCP=<wlan_handle>:
            api_name: StationGetConnectionParams
            desc: Reads the connection parameters for the connection.
            responses:
              +UWSCP:<wlan_handle>,<ssid>:
                at_client_ignore_params:
                - wlan_handle
                desc: Successful read response
        parameters:
          wlan_handle:
            type: wlan_handle
          ssid:
            type: ssid
      AT+UWSIPS:
        brief: Wi-Fi Station IP Static configuration
        syntax:
          AT+UWSIPS=<wlan_handle>,<ip_addr>,<subnet_mask>,<gateway>[,<prim_dns>[,<sec_dns>]]:
            storable: true
            api_name: StationSetIpConfigStatic
            desc: Sets ip configuration to use static ip
        parameters:
          wlan_handle:
            type: wlan_handle
      AT+UWSIPD:
        brief: Wi-Fi Station IP with DHCP
        syntax:
          AT+UWSIPD=<wlan_handle>:
            storable: true
            api_name: StationSetIpConfigDhcp
            desc: Sets ip configuration to receive ip address via dhcp
        parameters:
          wlan_handle:
            type: wlan_handle
      AT+UWSIP:
        brief: Wi-Fi Station IP configuration
        syntax:
          AT+UWSIP=<wlan_handle>:
            api_name: StationGetIpConfig
            response_syntax_param: ip_mode
            desc: Read the current configuration for IP address assignment
            responses:
              +UWSIP:<wlan_handle>,<ip_mode>:
                response_syntax_values:
                - 0
                at_client_ignore_params:
                - wlan_handle
                desc: Response if IP mode is DHCP
              +UWSIP:<wlan_handle>,<ip_mode>,<ip_addr>,<subnet_mask>,<gateway>,<prim_dns>,<sec_dns>:
                response_syntax_values:
                - 1
                at_client_ignore_params:
                - wlan_handle
                desc: Response if IP mode is set to be static
        parameters:
          wlan_handle:
            type: wlan_handle
          ip_mode:
            type: ip_mode
      AT+UWTS0:
        visibility: hidden
        brief: Wi-Fi Tuning Settings, 40Mhz setting
        desc: Turn 40Mhz channels on and off.
        notes: This command is EXPERIMENTAL and untested.
        syntax:
          AT+UWTS0=<enabled>:
            storable: true
            requires_reboot: true
            desc: Set 40Mhz channels on or off
          AT+UWTS0?:
            desc: Read Wi-Fi 40Mhz setting
            responses:
              +UWTS0:<enabled>:
                desc: Successful read response
        parameters:
          enabled:
            type: enabled
      AT+UWTS1:
        visibility: hidden
        brief: Wi-Fi Tuning Settings, Adaptivity setting
        notes: This command is EXPERIMENTAL and untested.
        syntax:
          AT+UWTS1=<adaptivity_type>:
            storable: true
            requires_reboot: true
            desc: Set the adaptivity level
          AT+UWTS1?:
            desc: Read the adaptivity level
            responses:
              +UWTS1:<adaptivity_type>:
                desc: Successful read response
        parameters:
          adaptivity_type:
            type: adaptivity_type
      AT+UWSC:
        brief: Wi-Fi Station Connect
        syntax:
          AT+UWSC=<wlan_handle>:
            storable: true
            api_name: StationConnect
            desc: Initiate connection to Wi-Fi network
        parameters:
          wlan_handle:
            type: wlan_handle
      AT+UWSDC:
        brief: Wi-Fi Station Disconnect
        syntax:
          AT+UWSDC:
            api_name: StationDisconnect
            desc: Disconnect from Wi-Fi network
      AT+UWSNST:
        brief: Wi-Fi Station Network Status
        syntax:
          AT+UWSNST=<net_status_id>:
            api_name: StationGetNetworkStatus
            desc: Show current status of Wi-Fi station network interface
            responses:
              +UWSNST:<net_status_id>,<net_status_val>:
                at_client_ignore_params:
                - net_status_id
                desc: Send for every applicable status
          AT+UWSNST?:
            api_name: StationListNetworkStatus
            multiline_response: true
            desc: Show current status of Wi-Fi station network interface
            responses:
              +UWSNST:<net_status_id>,<net_status_val>:
                desc: Send for every applicable status
      AT+UWRD:
        brief: Wi-Fi Regulatory Domain
        syntax:
          AT+UWRD=<reg_domain>:
            api_name: SetRegulatoryDomain
            storable: true
            desc: Set the regulatory domain for all Wi-Fi interfaces. This will configure
              the channel list and power levels for Wi-Fi. Make sure to set the correct
              code for the region the device will be operating in. Both 2.4 and 5
              GHz band is always operative. Set the domain before starting AP or Station
          AT+UWRD?:
            api_name: GetRegulatoryDomain
            desc: Read regulatory domain
            responses:
              +UWRD:<reg_domain>:
                desc: Current regulatory domain
        parameters:
          reg_domain:
            type: reg_domain
      AT+UWCL:
        brief: Wi-Fi Channel List
        syntax:
          AT+UWCL=<channel_list>:
            api_name: SetChannelList
            storable: true
            desc: Together with the regulatory domain, the channel list determines
              which channels to used during scanning and connection, a mix of 2.4
              and 5 GHz channels is possible. Note that the brackets [ ] must be included
              in the command, example AT+UWCL=[1,6,11,48,64]
          AT+UWCL?:
            api_name: GetChannelList
            desc: Read the current channel list
            responses:
              +UWCL:<channel_list>:
                desc: Current channel list
        parameters:
          channel_list:
            type: int_list
            length: 1..40
      AT+UWCLR:
        brief: Wi-Fi Channel List Reset
        syntax:
          AT+UWCLR:
            desc: Reset the channel list
      AT+UWAC:
        brief: Wi-Fi Active Channels
        syntax:
          AT+UWAC?:
            api_name: GetActiveChannels
            desc: Get the active channels that are used for scan and connection
            responses:
              +UWAC:<channel_list>:
                desc: List of active channels
        parameters:
          channel_list:
            type: int_list
            length: 0..40
      AT+UWMOP:
        brief: Set Max Wi-Fi Output Power
        syntax:
          AT+UWMOP=<int_dBm>:
            storable: true
            requires_reboot: true
            desc: "Set or read the Wi-Fi Max Output Power for all interfaces.\nThe\
              \ Output Power is specified in dBm.\nThe valid range is from -10 dBm\
              \ to +40 dBm but the actual supported range may vary between different\
              \ products.\n"
          AT+UWMOP?:
            desc: "Read current Wi-Fi Max Output Power level. Will return error if\
              \ the Wi-Fi Max Output Power has not been set\nand the default power\
              \ level is used.\n"
            responses:
              +UWMOP:<int_dBm>:
                desc: Successful read response.
      AT+UWMOPC:
        brief: Wi-Fi Max Output Power Clear
        desc: "Clear any previously set Wi-Fi Max Output Power level, and revert to\
          \ the default Max Output Power level.\n"
        syntax:
          AT+UWMOPC:
            storable: true
            requires_reboot: true
            api_name: ClearMaxOutputPower
            desc: Clear any previously set Wi-Fi Max Output Power level.
      AT+UWATI:
        visibility: internal
        brief: Wi-Fi Adaptivity Threshold Internal
        desc: Internal command to set adaptivity threshold directly to the driver
        notes: INTERNAL ONLY. Can not be exposed to any customer
        syntax:
          AT+UWATI=<hex_threshold>:
            storable: true
            requires_reboot: true
            desc: Set the adaptivity threshold.
        parameters:
          hex_threshold:
            type: byte_array
            length: 1..1
            desc: Adaptivity threshold
      AT+UWSRCI:
        visibility: hidden
        brief: Wi-Fi Station Re-Connect Internal
        notes: "After calling this, ${ref:AT+UWSDC} needs to be called to \"disconnect\"\
          \ even if connection has failed before it is possible to call this command\
          \ again\n"
        syntax:
          AT+UWSRCI=<enabled>:
            storable: true
            desc: Enable/disable auto-reconnect feature.
        parameters:
          enabled:
            type: enabled
      AT+UWSSC:
        brief: Wi-Fi Station Scan
        syntax:
          AT+UWSSC:
            api_name: StationScanDefault
            multiline_response: true
            desc: Initiate synchronous Wi-Fi scan (will lock AT interface until scan
              has finished)
            responses:
              +UWSSC:<bssid>,<ssid>,<channel>,<rssi>,<authentication_suites>,<unicast_ciphers>,<group_ciphers>:
                desc: Successful scan response
          AT+UWSSC=<scan_mode>[,<ssid>]:
            api_name: StationScan
            multiline_response: true
            desc: Initiate synchronous Wi-Fi scan (will lock AT interface until scan
              has finished)
            responses:
              +UWSSC:<bssid>,<ssid>,<channel>,<rssi>,<authentication_suites>,<unicast_ciphers>,<group_ciphers>:
                desc: Successful scan response
        parameters:
          scan_mode:
            desc: Choose how to scan
            default: Active
            type: enumerator
            values:
              active:
                value: 0
                desc: Active
              passive:
                value: 1
                desc: Passive
          bssid:
            desc: BSSID
            type: mac_addr
          ssid:
            type: ssid
          channel:
            desc: Channel
            type: integer
          rssi:
            desc: RSSI
            type: integer
          authentication_suites:
            desc: Authentication suites. Bit 0 = shared secret, 1 = PSK, 2 = EAP,
              3 = WPA, 4 = WPA2, 5 = WPA3
            type: integer
          unicast_ciphers:
            type: integer
            desc: unicast ciphers. Bit 0 = WEP64, 1 = WEP128, 2 = TKIP, 3 = AES/CCMP
          group_ciphers:
            type: integer
            desc: group ciphers. Bit 0 = WEP64, 1 = WEP128, 2 = TKIP, 3 = AES/CCMP
      AT+UWSST:
        brief: Wi-Fi Station Status
        syntax:
          AT+UWSST=<status_id>:
            api_name: StationStatus
            response_syntax_param: status_id
            desc: Read status
            responses:
              +UWSST:<status_id>,<ssid>:
                response_syntax_values:
                - 0
                desc: Read response for SSID
              +UWSST:<status_id>,<bssid>:
                response_syntax_values:
                - 1
                desc: Read response for BSSID
              +UWSST:<status_id>,<int_val>:
                response_syntax_values:
                - 2
                - 3
                - 4
                desc: Read response for Channel, Connection status and RSSI
          AT+UWSST:
            desc: Read status
            responses:
              +UWSST:<status_id>,<ssid>:
                desc: Read response for SSID
              +UWSST:<status_id>,<bssid>:
                desc: Read response for BSSID
              +UWSST:<status_id>,<int_val>:
                desc: Read response for Channel, Connection status and RSSI
        parameters:
          ssid:
            type: ssid
          status_id:
            type: enumerator
            values:
              ssid:
                value: 0
                desc: SSID of the connected AP
              bssid:
                desc: BSSID of the connected AP
                value: 1
              channel:
                desc: Active channel
                value: 2
              connection:
                desc: Connection status, 1 = not connected, 2 = Connected
                value: 3
              rssi:
                desc: RSSI value of the current connection; will return -32768, if
                  not connected.
                value: 4
          int_val:
            desc: RSSI, Connection status  or Channel
            type: integer
      AT+UWAPA:
        brief: Wi-Fi Access Point Activate
        syntax:
          AT+UWAPA:
            storable: true
            api_name: ApActivate
            desc: Start an access point with the current access point configuration.
      AT+UWAPD:
        brief: Wi-Fi Access Point Deactivate
        syntax:
          AT+UWAPD:
            storable: true
            api_name: ApDeactivate
            desc: Brings down Wi-Fi access point and disconnect all connected stations
      AT+UWAPCPI:
        brief: Wi-Fi AP Connection Parameters Internal
        visibility: internal
        syntax:
          AT+UWAPCPI=<ssid>,<channel>[,<hidden_ssid>]:
            storable: true
            desc: Sets connection parameters for the AP configuration. This command
              allows you to use any channel
        parameters:
          ssid:
            type: ssid
          channel:
            type: integer
          hidden_ssid:
            desc: "SSID visibility control\nFlag 0 = visible, 1 = hidden\n"
            type: integer
            valid_values: 0..1
            default: 0
      AT+UWAPCP:
        brief: Wi-Fi AP Connection Parameters
        syntax:
          AT+UWAPCP=<ssid>[,<channel>]:
            storable: true
            api_name: ApSetConnectionParams
            desc: Sets connection parameters for the AP configuration
          AT+UWAPCP?:
            api_name: ApGetConnectionParams
            desc: Read the current connection parameters
            responses:
              +UWAPCP:<ssid>,<channel>:
                desc: Successful read response
        parameters:
          ssid:
            type: ssid
          channel:
            desc: channel
            type: enumerator
            default: 6
            values:
              1:
                value: 1
                desc: '1'
              2:
                value: 2
                desc: '2'
              3:
                value: 3
                desc: '3'
              4:
                value: 4
                desc: '4'
              5:
                value: 5
                desc: '5'
              6:
                value: 6
                desc: '6'
              7:
                value: 7
                desc: '7'
              8:
                value: 8
                desc: '8'
              9:
                value: 9
                desc: '9'
              10:
                value: 10
                desc: '10'
              11:
                value: 11
                desc: '11'
              36:
                value: 36
                desc: '36'
              40:
                value: 40
                desc: '40'
              44:
                value: 44
                desc: '44'
              48:
                value: 48
                desc: '48'
      AT+UWAPSW:
        brief: Wi-Fi AP Security WPA
        syntax:
          AT+UWAPSW=<passphrase>[,<wpa_version>]:
            storable: true
            api_name: ApSetSecurityWpa
            desc: Sets WPA parameters for the AP config
      AT+UWAPSO:
        brief: Wi-Fi AP Security Open
        syntax:
          AT+UWAPSO:
            storable: true
            api_name: ApSetSecurityOpen
            desc: Sets security level to open for the AP config
      AT+UWAPS:
        brief: Wi-Fi AP Security
        syntax:
          AT+UWAPS?:
            api_name: ApGetSecurity
            response_syntax_param: security_mode
            desc: Get the current security configuration for Wi-Fi AP
            responses:
              +UWAPS:<security_mode>,<wpa_version>:
                response_syntax_values:
                - 1
                at_client_ignore_params:
                - wlan_handle
                desc: Response if security mode is WPA
              +UWAPS:<security_mode>:
                response_syntax_values:
                - 0
                at_client_ignore_params:
                - wlan_handle
                desc: Response if security mode is Open
        parameters:
          security_mode:
            type: security_mode
      AT+UWAPCS:
        brief: Wi-Fi Access Point Connected Stations
        syntax:
          AT+UWAPCS?:
            api_name: ApListStations
            multiline_response: true
            desc: Get a list of connected stations. One response will be sent for
              each connected station
            responses:
              +UWAPCS:<mac>:
                desc: A station that is connected to the access point
      AT+UWAPNST:
        brief: Wi-Fi Access Point Network Status
        syntax:
          AT+UWAPNST=<net_status_id>:
            api_name: ApGetNetworkStatus
            desc: Show current status of Wi-Fi station network interface
            responses:
              +UWAPNST:<net_status_id>,<net_status_val>:
                at_client_ignore_params:
                - net_status_id
                desc: Send for every applicable status
          AT+UWAPNST?:
            api_name: ApListNetworkStatus
            multiline_response: true
            desc: Show current status of Wi-Fi station network interface
            responses:
              +UWAPNST:<net_status_id>,<net_status_val>:
                desc: Send for every applicable status
      AT+UWSROE:
        brief: Wi-Fi Station Roaming Enable/Disable
        syntax:
          AT+UWSROE=<roaming>:
            storable: true
            api_name: SetWifiRoaming
            desc: Set Wi-Fi station roaming enabled or disabled.
          AT+UWSROE?:
            api_name: GetWifiRoaming
            desc: Get Wi-Fi station roaming enabled or disabled
            responses:
              +UWSROE:<roaming>:
                desc: Successful read response
        parameters:
          roaming:
            type: enumerator
            default: 0
            values:
              disable:
                desc: Disable roaming
                value: 0
              enable:
                desc: Enable roaming
                value: 1
      AT+UWSROS:
        brief: Wi-Fi Station Roaming Settings
        desc: Get and set Wi-Fi roaming related settings
        syntax:
          AT+UWSROS0=<roaming_scanning_threshold>:
            storable: true
            api_name: StationSetRoamingBGScanThreshold
            requires_reboot: false
            desc: Write the threshold for when to start roaming background scanning,
              in dBm.
          AT+UWSROS0?:
            api_name: StationGetRoamingBGScanThreshold
            desc: Read Connection Interval minium.
            responses:
              +UWSROS0:<roaming_scanning_threshold>:
                desc: Successful read of background scanning threshold.
          AT+UWSROS1=<roaming_switch_limit>:
            storable: true
            requires_reboot: false
            api_name: StationSetRoamingSwitchLimit
            desc: Write the roaming switch limit.
          AT+UWSROS1?:
            api_name: StationGetRoamingSwitchLimit
            desc: Read roaming switch limit.
            responses:
              +UWSROS1:<roaming_switch_limit>:
                desc: Successful read of roaming switch limit
          AT+UWSROS2=<roaming_scan_interval>:
            storable: true
            requires_reboot: false
            api_name: StationSetRoamingScanInterval
            desc: Write the interval in milliseconds to trigger roaming background
              scan.
          AT+UWSROS2?:
            api_name: StationGetRoamingScanInterval
            desc: Read roaming scan interval
            responses:
              +UWSROS2:<roaming_scan_interval>:
                desc: Successful read of roaming scan interval in milliseconds.
          AT+UWSROS3=<roaming_aggressive>:
            storable: true
            requires_reboot: false
            api_name: StationSetAggressiveRoaming
            desc: Set aggressive roaming to enabled or disabled. When this option
              is disabled (default), roaming will perform a connection handover if
              an newly found Access Point has an RSSI of <roaming_scanning_threshold>
              + <roaming_switch_limit> dB or better. When this option is enabled,
              roaming will perform a connection handover if an newly found Access
              Point has an RSSI that is at least <roaming_switch_limit> dB above its
              current value.
          AT+UWSROS3?:
            api_name: StationGetAggressiveRoaming
            desc: Get aggressive roaming enabled or disabled.
            responses:
              +UWSROS3:<roaming_aggressive>:
                desc: Successful read response
          AT+UWSROS4=<roaming_delay_time>:
            storable: true
            requires_reboot: false
            api_name: StationSetRoamingDelayMs
            desc: Write the delay time roaming waits before performing handover.
          AT+UWSROS4?:
            api_name: StationGetRoamingDelayMs
            desc: Read roaming delay time.
            responses:
              +UWSROS4:<roaming_delay_time>:
                desc: Successful read of roaming delay.
          AT+UWSROS5=<roaming_channels>:
            storable: true
            requires_reboot: false
            api_name: StationSetRoamingAllChannels
            desc: Set whether to perform roaming on all channels. If set to false
              the wifi station will only scan the channel used in the current connection.
              If all access points uses the same channel, roaming on this channel
              only will give a much faster and less intrusive roaming.
          AT+UWSROS5?:
            api_name: StationGetRoamingAllChannels
            desc: Read whether to perform roaming on all channels.
            responses:
              +UWSROS5:<roaming_channels>:
                desc: Successful read.
        parameters:
          roaming_scanning_threshold:
            desc: Threshold in dBm where background scanning for roaming is started
            type: integer
            valid_values: -95..0
            default: -70
          roaming_switch_limit:
            desc: Switch limit
            type: integer
            valid_values: 1..50
            default: 10
          roaming_scan_interval:
            desc: Scan interval
            type: integer
            valid_values: 100..3600000
            default: 5000
          roaming_aggressive:
            type: enumerator
            default: 0
            values:
              disable:
                desc: Disable aggressive roaming
                value: 0
              enable:
                desc: Enable aggressive roaming
                value: 1
          roaming_delay_time:
            desc: Roaming delay
            type: integer
            valid_values: 0..30000
            default: 0
          roaming_channels:
            desc: Roaming on all channels or current channel
            type: enumerator
            default: 1
            values:
              current_channel:
                desc: Roaming on current channel
                value: 0
              all:
                desc: Roaming on all channels
                value: 1
  Socket:
    desc: "The socket AT commands are used for creating and interfacing TCP/UDP sockets.\n"
    parameters:
      socket_handle:
        type: integer
        desc: Socket identifier be used for any operation on that socket.
      string_data:
        type: string
        desc: Data encoded as ascii chars.
        length: 0..1000
        null_terminated: false
      data_bytes:
        type: byte_array
        desc: Raw data bytes.
      remote_ip:
        type: ip_addr
        desc: The ip address of the remote peer.
      remote_port:
        type: integer
        valid_values: 1..65535
        desc: The port of the remote peer.
      protocol:
        desc: IP protocol.
        type: enumerator
        values:
          tcp:
            value: 6
            desc: TCP
          udp:
            value: 17
            desc: UDP
      pref_ip_ver:
        type: enumerator
        desc: Selects the preferred IP address type to use.
        default: 0
        values:
          ipv4:
            value: 0
            desc: IPv4 address.
          ipv6:
            value: 1
            desc: IPv6 address.
    urcs:
      +UESOC:<socket_handle>:
        api_name: Connect
        brief: Event Socket Connection
        desc: Event is sent out after a successful connection to a remote peer.
        notes: TCP only.
      +UESODA:<socket_handle>,<number_bytes>:
        api_name: DataAvailable
        brief: Event Socket Data Available
        desc: Data is available to be read. This will be sent out when using the buffered
          data mode.
        parameters:
          number_bytes:
            type: integer
            desc: Number of bytes available to read. If socket is a UDP socket this
              number refers to the size of the next datagram.
      +UESODS:<socket_handle>,<string_data>:
        output_payload: string
        brief: Event Socket Data String
        desc: Incoming on TCP socket data represented as a string.
      +UESODSF:<socket_handle>,<remote_ip>,<remote_port>,<string_data>:
        output_payload: string
        brief: Event Socket Data String From
        desc: Incoming on UDP socket data represented as a string.
      +UESODB:<socket_handle>{binary_data}:
        output_payload: binary
        brief: Event Socket Data Binary
        desc: Incoming on TCP socket data represented as binary data.
        parameters:
          binary_data:
            type: binary
            desc: The received data.
      +UESODBF:<socket_handle>,<remote_ip>,<remote_port>{binary_data}:
        output_payload: binary
        brief: Event Socket Data Binary From
        desc: Incoming on UDP socket data represented as binary data.
        parameters:
          binary_data:
            type: binary
            desc: The received data.
      +UESOCL:<socket_handle>:
        brief: Event Socket Closed
        api_name: Closed
        desc: "Event is sent out either when a socket was closed (by the remote or\
          \ timed out) or when a connection to a remote peer has failed.\nWhen this\
          \ event is sent out the socket has been fully closed and the handle can\
          \ be re-used.\n"
        notes: If there are unread data available, this event will not be sent out
          until all data has been read.
      +UESOIC:<socket_handle>,<remote_ip>,<listening_socket_handle>:
        brief: Event Socket Incoming Connection
        api_name: IncomingConnection
        desc: This event is sent when there is an incoming connection for a server
          socket.
        parameters:
          listening_socket_handle:
            type: integer
            desc: The handle of the new connected socket. Use this for any further
              operations on the connection.
    commands:
      AT+USOCR:
        brief: Create Socket
        syntax:
          AT+USOCR=<protocol>[,<pref_ip_ver>]:
            api_name: Create
            desc: "Creates a socket and associates it with the specified protocol\
              \ (TCP or UDP).\n"
            responses:
              +USOCR:<socket_handle>:
                desc: Successful creation of socket.
      AT+USOPCR:
        brief: Create Persistent Socket
        syntax:
          AT+USOPCR=<protocol>[,<pref_ip_ver>]:
            storable: true
            desc: "Creates a persistent socket and associates it with the specified\
              \ protocol (TCP or UDP).\nA persistent socket will automatically re-connect\
              \ when connection is lost.\nIt can also be stored so that the connection\
              \ initiated on boot.\n"
            responses:
              +USOPCR:<socket_handle>:
                desc: Successful creation of persistent socket.
      AT+USOTLS:
        brief: Socket TLS
        syntax:
          AT+USOTLS=<socket_handle>,<tls_version>[,<ca_name>[,<client_cert_name>,<client_key_name>]]:
            api_name: SetTLS
            desc: Add a TLS context to a socket. This is only valid for TCP client
              sockets.
          AT+USOTLS=<socket_handle>:
            api_name: GetTLS
            desc: Get the TLS context information for a socket.
            responses:
              +USOTLS:<socket_handle>,<tls_version>,<ca_name>,<client_cert_name>,<client_key_name>:
                desc: Successful response with the TLS context information for the
                  specified socket. The response includes the TLS version, CA name,
                  client certificate name, and client key name.
        parameters:
          tls_version:
            type: tls_version
          ca_name:
            type: ca_name
          client_cert_name:
            type: client_cert_name
          client_key_name:
            type: client_key_name
      AT+USOC:
        brief: Socket Connect
        desc: "For a TCP socket, this command will perform the TCP negotiation (3-way\
          \ handshake) to open a connection and for a UDP socket this command will\
          \ just declare the remote host address and port for later use with other\
          \ socket operations.\n"
        syntax:
          AT+USOC=<socket_handle>,<host_address>,<remote_port>:
            api_name: Connect
            desc: Establish a peer-to-peer connection to the specified remote host
              on the given remote port.
        notes: "This command is non-blocking by default (can be configured with ${ref:AT+USOO}).\n\
          \n**Notes for TCP sockets:**  \nWhen socket is non-blocking (default), a\
          \ connection is not fully set up until ${ref:+UESOC} URC is received.\n\n\
          **Notes for UDP sockets:**  \nErrors will not be reported prior to an attempt\
          \ to write or read data on the socket.\nSince UDP is connectionless no ${ref:+UESOC}\
          \ event will be sent, instead as soon as this command return OK the socket\
          \ is ready for reading/writing data.\n"
        parameters:
          host_address:
            desc: Remote host IP address or domain name of the remote host.
            type: string
            length: 0..128
      AT+USOP:
        brief: Socket Persistent
        syntax:
          AT+USOP=<socket_handle>,<host_address>,<remote_port>:
            storable: true
            requires_reboot: true
            desc: "Configure a TCP link with automatic re-connection. As opposed to\
              \ ${ref:AT+USOC}, this command will not initiate\na connection directly\
              \ but is used for configuring a link that is automatically setup on\
              \ boot.\n"
        parameters:
          host_address:
            desc: Remote host IP address or domain name.
            type: string
            length: 0..128
        notes: "Only one configuration is supported at the moment.\n"
        example: "Example of setting up a persistent TCP client connection that is\
          \ loaded on boot:\nAT+USOPCR=6,0\nAT+USOP=0,192.168.0.10,30123\nAT&W\nAT+CPWROFF\n\
          Please note that WiFi must also be setup.\n"
      AT+USOPR:
        brief: Socket Persistent Remove
        syntax:
          AT+USOPR=<config_id>:
            storable: true
            desc: "Removes an persistent socket configuration created by ${ref:AT+USOPCR}.\n"
        parameters:
          config_id:
            desc: Configuration ID
            type: integer
        notes: The corresponding socket will be automatically closed.
      AT+USOPL:
        brief: Socket Persistent List
        syntax:
          AT+USOPL?:
            desc: "List all persistent socket configurations.\n"
            responses:
              +USOPL:<socket_handle>,<host_address>,<remote_port>,<local_port>:
                desc: The response for each persistent configuration.
        parameters:
          config_id:
            desc: Configuration ID.
            type: integer
          host_address:
            desc: Remote host IP address or domain name of the remote host.
            type: string
            length: 0..128
          local_port:
            type: integer
            valid_values: 0..65535
            desc: Local port used by the socket, range 1-65535. 0 means there is no
              local port configured, a random port will be assigned by the system.
      AT+USORM:
        brief: Socket Receive Mode
        syntax:
          AT+USORM=<read_mode>:
            api_name: SetReadMode
            storable: true
            requires_reboot: true
            notes: Any created sockets or created persistent sockets will use the
              same receive mode as was configured when they were created
            desc: "Set the mode in which you would like to receive data in AT mode.\n"
          AT+USORM?:
            api_name: GetReadMode
            desc: Read the current receive mode
            responses:
              +USORM:<read_mode>:
                desc: Successful read response
        parameters:
          read_mode:
            type: read_mode
      AT+USOWS:
        brief: Socket Write String
        input_payload: string
        syntax:
          AT+USOWS=<socket_handle>,<string_data>:
            desc: "Writes string data to the specified socket.\nThe command can be\
              \ used for both TCP and UDP sockets after calling ${ref:AT+USOC}. \n\
              If socket is not ready to be written, generic negative error will be\
              \ returned. \nCheck BSD errno (see BSD standard) by calling ${ref:AT+USOE}.\n"
            responses:
              +USOWS:<socket_handle>,<written_length>:
                at_client_ignore_params:
                - socket_handle
                desc: Successful write response.
        parameters:
          written_length:
            type: integer
            desc: Data length that was written.
        notes: "This command is non-blocking.\n\nThe command may respond writing less\
          \ data than what was passed to the command.\nThis means that the socket\
          \ transmit buffer is currently full and data not successfully written must\
          \ be retransmitted later.\n"
      AT+USOWB:
        brief: Socket Write Binary
        input_payload: binary
        syntax:
          AT+USOWB=<socket_handle>{binary_data}:
            api_name: Write
            desc: Writes binary data to the specified socket in binary mode.
            responses:
              +USOWB:<socket_handle>,<written_length>:
                at_client_ignore_params:
                - socket_handle
                at_client_return_param: written_length
                desc: Successful write response.
        parameters:
          written_length:
            type: integer
            desc: Data length that was actually written to socket.
          binary_data:
            type: binary
            desc: The data to write.
        notes: "This command is non-blocking.\n\nThe command may respond writing less\
          \ data than what was passed to the command.\nThis means that the socket\
          \ transmit buffer is currently full and data not successfully written must\
          \ be retransmitted later.\n"
      AT+USOCL:
        brief: Close socket
        syntax:
          AT+USOCL=<socket_handle>:
            api_name: Close
            desc: "Closes the specified socket.\n\nThe command blocks the AT command\
              \ interface until the completion of the socket close operation.\nWhen\
              \ this function returns OK the socket is cleaned up and fully closed.\n"
        parameters:
          socket_handle:
            type: integer
            desc: Socket identifier to be used for any future operation on that socket.
            valid_values: 0..256
      AT+USORS:
        brief: Socket Read String
        output_payload: string
        syntax:
          AT+USORS=<socket_handle>,<length>:
            desc: "Reads the specified amount of data from the specified socket.\n\
              Note that the data should include no null terminator characters.\n"
            responses:
              +USORS:<socket_handle>,<length>,<string_data>:
                at_client_ignore_params:
                - socket_handle
                desc: Successful read response.
        parameters:
          length:
            type: integer
            desc: Number of bytes to read.
            valid_values: 1..1000
        notes: This command is non-blocking.
      AT+USORB:
        brief: Socket Read Binary
        output_payload: binary
        syntax:
          AT+USORB=<socket_handle>,<length>:
            api_name: Read
            bin_out_length_param: length
            desc: "Reads the specified amount of data from the specified socket in\
              \ binary mode.\n"
            responses:
              +USORB:<socket_handle>{binary_data}:
                at_client_ignore_params:
                - socket_handle
                desc: Successful read response.
        parameters:
          length:
            type: integer
            desc: Number of bytes to read.
            valid_values: 1..1000
          binary_data:
            type: binary
            desc: The available data. Please note that the number of bytes may be
              less than requested.
      AT+USOE:
        brief: Socket Error
        syntax:
          AT+USOE:
            api_name: GetLastError
            desc: Retrieves the last error that occurred in any socket operation,
              stored in the socket errno.
            responses:
              +USOE:<error_code>:
                desc: Successful response.
        parameters:
          error_code:
            type: integer
            desc: BSD error code. See BSD standard for error code definitions.
      AT+USOB:
        brief: Socket Bind
        syntax:
          AT+USOB=<socket_handle>,<local_port>:
            api_name: Bind
            desc: Binds the specified socket to the specified local port.
        parameters:
          local_port:
            type: integer
            valid_values: 1..65535
            desc: Local port of service, range 1-65535. Port numbers below 1024 are
              not recommended since they are usually reserved
      AT+USOL:
        brief: Socket Listen
        syntax:
          AT+USOL=<socket_handle>[,<port>]:
            api_name: Listen
            desc: Sets the specified socket in listening mode on the specified port
              of service, waiting for incoming connections (TCP) or data (UDP).
        parameters:
          port:
            type: integer
            valid_values: 1..65535
            desc: Port of service, range 1-65535. Port numbers below 1024 are not
              recommended since they are usually reserved
        notes: "The port parameter is deprecated and may be ignored in future releases.\
          \ It is kept for backwards compatibility. If the port is specified, the\
          \ socket will listen on the specified port. If the port is not specified,\
          \ the socket will listen on the port it was bound to (if it was bound).\
          \ If the socket was not bound, the port will be automatically assigned by\
          \ the system. If the socket is already bound to a port this command will\
          \ return an error.\nFor UDP sockets, this command corresponds directly to\
          \ the ${ref:AT+USOB} command, which binds the socket to the specified port."
      AT+USORF:
        brief: Socket Read From
        output_payload: string
        replaced_by: AT+USORFS
        syntax:
          AT+USORF=<socket_handle>,<length>:
            desc: Reads the specified amount of data from the specified UDP socket.
            responses:
              +USORF:<socket_handle>,<remote_ip>,<remote_port>,<length>,<string_data>:
                desc: Successful read response.
        parameters:
          length:
            type: integer
            desc: Number of bytes to read.
            valid_values: 1..900
      AT+USORFS:
        brief: Socket ReceiveFrom String
        output_payload: string
        syntax:
          AT+USORFS=<socket_handle>,<length>:
            desc: Reads the specified amount of data from the specified UDP socket.
            responses:
              +USORFS:<socket_handle>,<remote_ip>,<remote_port>,<length>,<string_data>:
                desc: Successful read response.
        parameters:
          length:
            type: integer
            desc: Number of bytes to read.
            valid_values: 1..900
      AT+USORFB:
        brief: Socket ReceiveFrom Binary
        output_payload: binary
        syntax:
          AT+USORFB=<socket_handle>,<length>:
            api_name: ReceiveFrom
            bin_out_length_param: length
            desc: "Reads the specified amount of data from the specified UDP socket.\n"
            responses:
              +USORFB:<socket_handle>,<remote_ip>,<remote_port>{binary_data}:
                at_client_ignore_params:
                - socket_handle
                desc: Successful read response.
        parameters:
          length:
            type: integer
            desc: Number of bytes to read.
            valid_values: 1..1000
          binary_data:
            type: binary
            desc: The available data. Please note that the number of bytes may be
              less than requested.
      AT+USOSTS:
        brief: Socket SendTo String
        input_payload: string
        syntax:
          AT+USOSTS=<socket_handle>,<remote_ip>,<remote_port>,<string_data>:
            desc: Sends string data to the specified UDP socket.
            responses:
              +USOSTS:<socket_handle>,<written_length>:
                desc: Successful write response.
        parameters:
          written_length:
            type: integer
            desc: Data length that was written.
      AT+USOSTB:
        brief: Socket SendTo Binary
        input_payload: binary
        syntax:
          AT+USOSTB=<socket_handle>,<remote_ip>,<remote_port>{binary_data}:
            desc: Sends binary data to the specified UDP socket.
            api_name: SendTo
            responses:
              +USOSTB:<socket_handle>,<written_length>:
                at_client_ignore_params:
                - socket_handle
                at_client_return_param: written_length
                desc: Successful write response.
        parameters:
          written_length:
            type: integer
            desc: Data length that was written.
          binary_data:
            type: binary
            desc: The data to write.
      AT+USOPA:
        brief: Socket Peer Address
        syntax:
          AT+USOPA=<socket_handle>:
            api_name: GetPeerAddress
            desc: Get the address of remote peer.
            responses:
              +USOPA:<socket_handle>,<remote_ip>,<remote_port>:
                at_client_ignore_params:
                - socket_handle
                desc: Successful read response.
      AT+USOST:
        brief: Socket Status
        syntax:
          AT+USOST?:
            api_name: ListStatus
            multiline_response: true
            desc: List status for all created sockets.
            responses:
              +USOST:<socket_handle>,<protocol>,<status>:
                desc: Response for each created socket.
          AT+USOST=<socket_handle>:
            api_name: GetStatus
            desc: Get the status of a specific socket.
            responses:
              +USOST:<socket_handle>,<protocol>,<status>:
                at_client_ignore_params:
                - socket_handle
                desc: Successful response.
        parameters:
          status:
            type: enumerator
            values:
              not_connected:
                value: 0
                desc: Not Connected
              listening:
                value: 1
                desc: Listening
              connected:
                value: 2
                desc: Connected
      AT+USOO:
        brief: Socket Options
        syntax:
          AT+USOO=<socket_handle>,<option>,<value>:
            api_name: SetOption
            desc: Set a socket option. See available options below.
          AT+USOO=<socket_handle>,<option>:
            api_name: GetOption
            desc: Read a socket option for a socket
            responses:
              +USOO:<socket_handle>,<option>,<value>:
                at_client_ignore_params:
                - socket_handle
                - option
                desc: Successful read response
        parameters:
          option:
            desc: Available options to set
            type: enumerator
            values:
              no_delay:
                default: 0
                desc: "Turn on/off No delay feature for TCP sockets.\nInteger flag:\
                  \ 0 = off (i.e. Nagle algorithm enabled), 1 = on  (i.e. Nagle algorithm\
                  \ disabled)\nDefault: to 0\n"
                notes: "Turning this feature on will result in bad throughput performance\
                  \ on on baudrates higher than 115200. We recommend keeping this\
                  \ option off.\nThis will make no difference if applied to UDP sockets.\
                  \ \n"
                value: 0
              block:
                default: 0
                desc: "Set socket to be blocking or non blocking.\nInteger flag: 0\
                  \ = off, 1 = on.\nSockets are non-blocking by default (Note that\
                  \ read/write will always be non-blocking).\nCan only be set while\
                  \ the socket is in a non connected state.\nNote: Only valid for\
                  \ non-persistent TCP sockets, will have no effect on UDP sockets\n"
                value: 1
              keep_alive:
                default: 1
                desc: "Keep connections alive by sending keepalive probes.\nInteger\
                  \ flag: 0 = off, 1 = on.\nTo calculate the keepalive time us this\
                  \ formula KeepIdle + (KeepIntvl * KeepCnt).\nDefaults to 1.\nNote:\
                  \ Only valid for TCP sockets.\n"
                value: 2
              keep_idle:
                default: 3
                desc: "Set Keep Idle value for the socket.\nThis specifies the amount\
                  \ of time (in sec) that the connection must be idle before sending\
                  \ keepalive probes (if keepalive is enabled).\nDefaults to 3.\n\
                  Note: Only valid for TCP sockets.\n"
                value: 3
              keep_intvl:
                default: 3
                desc: "Set keep alive interval value for the socket. This is the time\
                  \ in seconds between two successive keepalive retransmissions. \n\
                  Defaults to 3.\nNote: Only valid for TCP sockets.\n"
                value: 4
              keep_cnt:
                default: 3
                desc: "Set keep alive counter value for the socket.\nThe number of\
                  \ unanswered probes required to force closure of the socket.\nDefaults\
                  \ to 3.\nNote: Only valid for TCP sockets.\n"
                value: 5
              broadcast:
                default: 0
                desc: "Set broadcast capability for UDP sockets.\nInteger flag: 0\
                  \ = off, 1 = on.\nWhen enabled, allows sending and receiving UDP\
                  \ packets to/from broadcast addresses.\nDefaults to 0 (disabled).\n\
                  Note: Only valid for UDP sockets.\n"
                value: 6
          value:
            type: integer
            desc: See option parameter
      AT+USOH:
        brief: Socket Host by Name
        syntax:
          AT+USOH=<host_name>:
            api_name: GetHostByName
            desc: Does a DNS lookup of a host name and returns the IP address.
            responses:
              +USOH:<host_ip>:
                desc: Successful read response.
        parameters:
          host_name:
            desc: Name to lookup.
            type: string
            length: 0..128
          host_ip:
            type: ip_addr
            desc: The ip address of the host.
  MQTT:
    desc: MQTT Commands
    parameters:
      mqtt_id:
        type: integer
        desc: MQTT Config ID
        valid_values: 0..0
      keep_alive:
        desc: MQTT keepalive in seconds. If set to 0, no keepalive is used
        type: integer
        default: 60
        valid_values: 0..65535
      qos:
        desc: Quality of Service (QoS) for the message or topic
        type: qos
      retain:
        type: enumerator
        desc: Retain flag for message
        default: 0
        values:
          no:
            desc: Do not retain message on broker
            value: 0
          yes:
            desc: Retain message on broker
            value: 1
      topic:
        type: string
        length: 0..256
        desc: Topic name or filter (wildcard allowed)
      message:
        type: string
        length: 0..1000
        desc: MQTT message
        null_terminated: false
      message_len:
        type: integer
        desc: Length of the MQTT message
      packet_id:
        type: integer
        desc: Packet ID of the message
      subscribe_action:
        type: enumerator
        desc: Subscribe or unsubscribe action
        values:
          subscribe:
            value: 0
            desc: Subscribe to topic
          unsubscribe:
            value: 1
            desc: Unsubscribe from topic
    urcs:
      +UEMQC:<mqtt_id>:
        api_name: Connect
        brief: Event MQTT Connected
        desc: Connected to MQTT broker
      +UEMQDC:<mqtt_id>,<disconnect_reason>:
        api_name: Disconnect
        brief: Event MQTT Disconnected
        desc: Disconnected from MQTT Broker
        parameters:
          disconnect_reason:
            desc: Disconnection reason
            type: integer
      +UEMQDA:<mqtt_id>,<message_len>:
        api_name: DataAvailable
        brief: Event MQTT Data Available
      +UEMQDD:<mqtt_id>,<message_len>:
        api_name: DataDropped
        brief: Event MQTT Data Dropped
      +UEMQPC:<mqtt_id>,<packet_id>,<message_len>:
        api_name: PublishCompleted
        brief: Event MQTT Publish Completed
      +UEMQSC:<mqtt_id>,<subscribe_action>:
        api_name: SubscribeCompleted
        brief: Event MQTT Subscribe Completed
    commands:
      AT+UMQCP:
        brief: MQTT Connection Parameters
        syntax:
          AT+UMQCP=<mqtt_id>,<hostname>,<port>[,<client_id>[,<username>[,<password>]]]:
            storable: true
            api_name: SetConnectionParams
            desc: "Set the MQTT connection parameters.\n"
          AT+UMQCP=<mqtt_id>:
            api_name: GetConnectionParams
            desc: "Get the MQTT connection parameters.\n"
            responses:
              +UMQCP:<mqtt_id>,<hostname>,<port>,<client_id>,<username>:
                at_client_ignore_params:
                - mqtt_id
                desc: Successful read response
        notes: Empty strings for username and password mean they will not be used
          during the connection.
        parameters:
          hostname:
            type: string
            length: 0..128
            desc: Hostname or IP address of the broker
          port:
            type: integer
            valid_values: 1..65535
            desc: The port of the broker
          client_id:
            desc: Client ID. Can be left empty to let the broker decide
            type: string
            length: 0..128
          username:
            type: string
            length: 0..128
          password:
            type: string
            length: 0..128
      AT+UMQC:
        brief: MQTT Connect to Broker
        syntax:
          AT+UMQC=<mqtt_id>:
            api_name: Connect
            desc: Connect to a broker using the MQTT config ID.
      AT+UMQKA:
        brief: MQTT Keep Alive
        syntax:
          AT+UMQKA=<mqtt_id>,<keep_alive>:
            storable: true
            api_name: SetKeepAlive
            desc: Set keepalive timeout for MQTT the MQTT config
          AT+UMQKA=<mqtt_id>:
            api_name: GetKeepAlive
            desc: Get keepalive timeout for MQTT config
            responses:
              +UMQKA:<mqtt_id>,<keep_alive>:
                at_client_ignore_params:
                - mqtt_id
                desc: Successful read response
      AT+UMQLWT:
        brief: MQTT Last Will and Testament
        syntax:
          AT+UMQLWT=<mqtt_id>,<topic>,<will_msg>[,<qos>[,<retain>]]:
            storable: true
            api_name: SetLastWillAndTestament
            desc: Add last will and testament configuration for the client
          AT+UMQLWT=<mqtt_id>:
            api_name: GetLastWillAndTestament
            desc: Get last will and testament configuration for the client
            responses:
              +UMQLWT:<mqtt_id>,<topic>,<will_msg>,<qos>,<retain>:
                at_client_ignore_params:
                - mqtt_id
                desc: Successful read response
        parameters:
          will_msg:
            type: string
            length: 0..256
      AT+UMQTLS:
        brief: MQTT TLS Configuration
        syntax:
          AT+UMQTLS=<mqtt_id>,<tls_version>[,<ca_name>[,<client_cert_name>,<client_key_name>]]:
            storable: true
            api_name: SetTLS
            desc: Setup MQTT TLS config. Certs do not have to be uploaded until connection.
          AT+UMQTLS=<mqtt_id>:
            response_syntax_param: tls_version
            api_name: GetTLS
            desc: Get TLS config
            responses:
              +UMQTLS:<mqtt_id>,<tls_version>,<ca_name>,<client_cert_name>,<client_key_name>:
                at_client_ignore_params:
                - mqtt_id
                response_syntax_values:
                - 1
                - 2
                - 3
                - 4
                desc: Successful read response
              +UMQTLS:<mqtt_id>,<tls_version>:
                at_client_ignore_params:
                - mqtt_id
                response_syntax_values:
                - 0
                desc: Successful read response with TLS off
        parameters:
          tls_version:
            type: tls_version
          ca_name:
            type: ca_name
          client_cert_name:
            type: client_cert_name
          client_key_name:
            type: client_key_name
      AT+UMQDC:
        brief: MQTT Disconnect
        syntax:
          AT+UMQDC=<mqtt_id>:
            api_name: Disconnect
            desc: "Disconnect the MQTT client from the broker.\nNote that the disconnection\
              \ is not complete until the ${ref:+UEMQDC} URC arrives.\n"
      AT+UMQPS:
        brief: MQTT Publish String
        syntax:
          AT+UMQPS=<mqtt_id>,<qos>,<retain>,<topic>,<message>:
            desc: Publish an MQTT message in string format to the specified topic.
            responses:
              +UMQPS:<mqtt_id>,<packet_id>:
                desc: Successful publish response
      AT+UMQPB:
        input_payload: binary
        brief: MQTT Publish Binary
        syntax:
          AT+UMQPB=<mqtt_id>,<qos>,<retain>,<topic>{binary_data}:
            api_name: Publish
            desc: Publish an MQTT message in binary format to the specified topic.
            responses:
              +UMQPB:<mqtt_id>,<packet_id>:
                at_client_ignore_params:
                - mqtt_id
                at_client_return_param: packet_id
                desc: Successful publish response
        parameters:
          binary_data:
            type: binary
            desc: The MQTT message data.
      AT+UMQS:
        brief: MQTT Subscribe
        syntax:
          AT+UMQS=<mqtt_id>,<subscribe_action>,<topic>[,<qos>]:
            api_name: Subscribe
            desc: Subscribe or unsubscribe to/from MQTT topic.
      AT+UMQRS:
        brief: MQTT Read String
        output_payload: string
        syntax:
          AT+UMQRS=<mqtt_id>:
            desc: Read available MQTT message in string format.
            responses:
              +UMQRS:<mqtt_id>,<topic>,<message_len>,<message>:
                desc: Successful read response
      AT+UMQRB:
        brief: MQTT Read Binary
        output_payload: binary
        syntax:
          AT+UMQRB=<mqtt_id>:
            api_name: Read
            desc: Read available MQTT message in binary format.
            responses:
              +UMQRB:<mqtt_id>,<topic>{binary_data}:
                at_client_ignore_params:
                - mqtt_id
                desc: Successful read response
        parameters:
          binary_data:
            type: binary
            desc: The MQTT message data. The maximum size of the binary data is 5000
              bytes.
  HTTP:
    desc: HTTP Commands
    parameters:
      session_id:
        type: integer
        desc: Unique http session identifier. Currently only one session is supported,
          0.
        valid_values: 0..0
      data_length:
        type: integer
        desc: Length of the data to be read
        valid_values: 1..1000
      byte_array_data:
        type: string
        desc: data encoded as a ascii chars.
        length: 0..1000
        null_terminated: false
      header_data:
        type: string
        desc: data encoded as a ascii chars.
        length: 0..1000
        null_terminated: true
      content_type:
        type: string
        length: 0..64
        desc: "The MIME type of the HTTP response.\n- text/html for HTML files\n-\
          \ text/plain for plain text files\n- image/jpeg for JPEG images\n- application/json\
          \ for JSON data\n- application/pdf for PDF files\n"
      content_length:
        type: integer
        desc: Size of the HTTP body in bytes.
      path:
        type: string
        length: 0..300
        desc: The path to the HTTP request.
      more_to_read:
        type: integer
        desc: Indicates if there is more data to be read.
        valid_values: 0..1
    commands:
      AT+UHTCCP:
        brief: HTTP Client Connection Parameters
        syntax:
          AT+UHTCCP=<session_id>,<host>[,<port>]:
            api_name: SetConnectionParams
            desc: "Set the HTTP connection parameters.\n"
        parameters:
          host:
            type: string
            length: 0..300
            desc: The host for the http session
          port:
            type: integer
            valid_values: 0..65535
            desc: The port for the http session
      AT+UHTCTLS:
        brief: HTTP Client TLS Configuration
        syntax:
          AT+UHTCTLS=<session_id>,<tls_version>[,<ca_name>[,<client_cert_name>,<client_key_name>]]:
            api_name: SetTLS
            desc: Add a TLS context to a http session.
          AT+UHTCTLS=<session_id>:
            api_name: GetTLS
            desc: Get the TLS context information for a http session.
            responses:
              +UHTCTLS:<session_id>,<tls_version>,<ca_name>,<client_cert_name>,<client_key_name>:
                desc: Provides the TLS context information for the specified socket,
                  including the TLS version, CA name, client certificate name, and
                  client key name. This response is returned upon successfully retrieving
                  the TLS configuration.
        parameters:
          tls_version:
            type: tls_version
          ca_name:
            type: ca_name
          client_cert_name:
            type: client_cert_name
          client_key_name:
            type: client_key_name
      AT+UHTCC:
        visibility: hidden
        brief: HTTP Client Connect
        syntax:
          AT+UHTCC=<session_id>:
            api_name: Connect
            desc: "Establishes the HTTP connection using parameters configured with\
              \ ${ref:AT+UHTCCP}.\n"
      AT+UHTCDC:
        brief: HTTP Client Disconnect
        syntax:
          AT+UHTCDC=<session_id>:
            api_name: Disconnect
            desc: "Disconnects the HTTP session identified by `<session_id>`.\n"
      AT+UHTCGH:
        brief: HTTP Client Get Header
        syntax:
          AT+UHTCGH=<session_id>[,<data_length>]:
            api_name: GetHeader
            desc: Read the HTTP response header up to `<data_length>` bytes. Several
              calls may be needed to get the complete header, if its larger than `<data_length>`
            responses:
              +UHTCGH:<session_id>,<more_to_read>,<byte_array_data>:
                desc: Complete HTTP header data.
      AT+UHTCGBB:
        brief: HTTP Client Get Body Binary
        output_payload: binary
        syntax:
          AT+UHTCGBB=<session_id>,<data_length>:
            api_name: GetBody
            bin_out_length_param: data_length
            desc: "Read the body of the last HTTP response, up to `<data_length>`\
              \ bytes, as binary data.\nCan be used several times, until all bytes\
              \ of the body has been read or the server closes the connection.\nIf\
              \ there is more data to be read this will be indicated by the response\
              \ parameter <more_to_read>.\nThe total length of the body may be found\
              \ in the Content-Length field of the header.\n"
            responses:
              +UHTCGBB:<session_id>,<more_to_read>{binary_data}:
                at_client_ignore_params:
                - session_id
                desc: Successful read response.
        parameters:
          binary_data:
            type: binary
            desc: The available data. Please note that the number of bytes may be
              less than requested.
      AT+UHTCGBS:
        brief: HTTP Client Get Body String
        output_payload: string
        syntax:
          AT+UHTCGBS=<session_id>,<data_length>:
            desc: "Read the body of the last HTTP response, up to `<data_length>`\
              \ bytes, as string data.\nCan be used several times, until all bytes\
              \ of the body has been read or the server closes the connection.\nIf\
              \ there is more data to be read this will be indicated by the response\
              \ parameter <more_to_read>.\nThe total length of the body may be found\
              \ in the Content-Length field of the header.\n"
            responses:
              +UHTCGBS:<session_id>,<more_to_read>,<data_length>,<byte_array_data>:
                desc: Successful read response.
      AT+UHTCGCL:
        visibility: hidden
        brief: HTTP Client Get Content Length
        syntax:
          AT+UHTCGCL=<session_id>:
            api_name: GetContentLength
            desc: Get the Content-Length header for HTTP requests.
            responses:
              +UHTCGCL:<content_length>:
                desc: Size of the HTTP body in bytes.
      AT+UHTCGCT:
        visibility: hidden
        brief: HTTP Client Get Content Type
        syntax:
          AT+UHTCGCT=<session_id>:
            api_name: GetContentType
            desc: Get the Content-Type (MIME type) for HTTP responses.
            responses:
              +UHTCGCT:<content_type>:
                desc: The MIME type of the HTTP response.
      AT+UHTCGAU:
        visibility: hidden
        brief: HTTP Client Get Authorization Type
        syntax:
          AT+UHTCGAU=<session_id>:
            api_name: GetAuthType
            desc: Get the Authorization type used in the HTTP header.
            responses:
              +UHTCGAU:<auth_type>:
                desc: Authorization type from the header.
        parameters:
          auth_type:
            type: string
            length: 0..64
            desc: Type of Authorization used (e.g., Basic, Bearer, Digest)
      AT+UHTCRHAF:
        brief: HTTP Client Request Header Add Field
        syntax:
          AT+UHTCRHAF=<session_id>,<field_name>,<field_value>:
            api_name: AddHeaderField
            desc: Add a custom header field to the current request. Using this will
              override any custom header set by {ref:AT+UHTCRHSC}. Up to 10 header
              fields can be added to one same http request
        parameters:
          field_name:
            type: string
            length: 1..30
          field_value:
            type: string
            length: 1..70
        notes: "If Content-Length is configured in the request header, multiple calls\
          \ to **POST** or **PUT** can be used to send\nContent-Length bytes of data\
          \ in one request.\n\nUsing this command will replace any header configuration\
          \ done using {ref:AT+UHTCRHCS}\n"
      AT+UHTCRHCS:
        brief: HTTP Client Request Header Custom String
        desc: Set a complete custom header for the HTTP request
        syntax:
          AT+UHTCRHCS=<session_id>,<header_data>:
            api_name: SetCustomHeader
            desc: Set a complete custom header for the HTTP request. This will override
              any configuration made with {ref:AT+UHTCRHAF}.
        notes: "If Content-Length is configured in the request header, multiple calls\
          \ to **POST** or **PUT** can be used to send\nContent-Length bytes of data\
          \ in one request.\nUsing this command will replace any header configuration\
          \ done using {ref:AT+UHTCRHAF}\n"
      AT+UHTCRHC:
        brief: HTTP Client Request Header Clear
        desc: Clear all current header configurations and use the default generated
          header
        syntax:
          AT+UHTCRHCC=<session_id>:
            desc: Clear all header configurations made by {ref:AT+UHTCRHCS} or {ref:AT+UHTCRHAF}
              for index
            api_name: ClearHeaderCustom
      AT+UHTCRP:
        brief: HTTP Client Request Path
        desc: Configure the path for the current http request
        syntax:
          AT+UHTCRP=<session_id>,<path>:
            desc: Configure the path for the current http request"
            api_name: SetRequestPath
          AT+UHTCRP=<session_id>:
            desc: Read the configured path for the current http request
            api_name: GetRequestPath
            responses:
              +UHTCRP:<session_id>,<path>:
                desc: Read the path of the current request.
      AT+UHTCRG:
        brief: HTTP Client Request GET
        syntax:
          AT+UHTCRG=<session_id>:
            api_name: GetRequest
            desc: Send a **GET** request to the configured URL with a minimal default
              header, or using the configured header if there is a configuration.
              Content-Length will always be 0.
      AT+UHTCRGH:
        brief: HTTP Client Request GET Header
        desc: Get the HTTP header that would be used in a **GET** request using the
          current configuration
        syntax:
          AT+UHTCRGH=<session_id>:
            api_name: GetGetRequestHeader
            desc: Return the HTTP header for a GET request
            responses:
              +UHTCRGH:<session_id>,<header_data>:
                desc: Read the path of the current request.
      AT+UHTCRD:
        brief: HTTP Client Request DELETE
        syntax:
          AT+UHTCRD=<session_id>[,<byte_array_data>]:
            api_name: DeleteRequest
            desc: "Send a **HTTP DELETE** request to the configured URL with a minimal\
              \ default header, or using the configured header if there is a configuration.\n"
      AT+UHTCRDH:
        brief: HTTP Client Request DELETE Header
        desc: Get the HTTP header that would be used in a **DELETE** request using
          the current configuration
        syntax:
          AT+UHTCRDH=<session_id>:
            api_name: GetDeleteRequestHeader
            desc: Return the HTTP header for a DELETE request
            responses:
              +UHTCRDH:<session_id>,<header_data>:
                desc: Read the header of the current request.
      AT+UHTCRPOS:
        brief: HTTP Client Request POST String
        output_payload: string
        desc: "Send a **POST** request with a minimal default header, or using the\
          \ configured header.\nIf Content-Length is configured one or more calls\
          \ to this function can be used to add in total this amount of data. If Content-Length\
          \ is not set\nin the header, then the amount of bytes provided in one call\
          \ to this function will be used as Content-Length\n"
        syntax:
          AT+UHTCRPOS=<session_id>,<byte_array_data>:
            desc: "Sends an HTTP POST request using a string as body.\n"
      AT+UHTCRPOB:
        brief: HTTP Client Request POST Binary
        desc: "Send a **POST** request with a minimal default header, or using the\
          \ configured header if there is a configuration.\nIf Content-Length is configured\
          \ one or more calls to this function can be used to add in total this amount\
          \ of data. If Content-Length is not set\nin the header, then the amount\
          \ of bytes provided in one call to this function will be used as Content-Length\n"
        input_payload: binary
        syntax:
          AT+UHTCRPOB=<session_id>{binary_data}:
            api_name: PostRequest
            desc: "Sends an HTTP POST request using binary data as body.\n"
            responses:
              +UHTCRPOB:<session_id>,<written_length>:
                at_client_ignore_params:
                - session_id
                at_client_return_param: written_length
                desc: Successful write response for POST binary.
        parameters:
          binary_data:
            type: binary
          written_length:
            type: integer
            desc: Data length that was written as body.
      AT+UHTCRPOH:
        brief: HTTP Client Request POST Header
        desc: Get the HTTP header that would be used in a **POST** request using the
          current configuration
        syntax:
          AT+UHTCRPOH=<session_id>:
            api_name: GetPostRequestHeader
            desc: Return the HTTP header for a POST request
            responses:
              +UHTCRPOH:<session_id>,<header_data>:
                desc: Read the header of the current request.
      AT+UHTCRPUS:
        brief: HTTP Client Request PUT String
        desc: "Send a **PUT** request with a minimal default header, or using the\
          \ configured header .\nIf Content-Length is configured one or more calls\
          \ to this function can be used to add in total this amount of data. If Content-Length\
          \ is not set\nin the header, then the amount of bytes provided in one call\
          \ to this function will be used as Content-Length\n"
        syntax:
          AT+UHTCRPUS=<session_id>,<byte_array_data>:
            desc: "Sends an HTTP PUT request using a string as body.\n"
      AT+UHTCRPUB:
        brief: HTTP Client Request PUT Binary
        desc: "Send a **PUT** request with a minimal default header, or using the\
          \ configured header.\nIf Content-Length is configured one or more calls\
          \ to this function can be used to add in total this amount of data. If Content-Length\
          \ is not set\nin the header, then the amount of bytes provided in one call\
          \ to this function will be used as Content-Length\n"
        input_payload: binary
        syntax:
          AT+UHTCRPUB=<session_id>{binary_data}:
            api_name: PutRequest
            desc: "Sends an HTTP PUT request using binary data as body.\n"
            responses:
              +UHTCRPUB:<session_id>,<written_length>:
                at_client_ignore_params:
                - session_id
                at_client_return_param: written_length
                desc: Successful write response for PUT binary.
        parameters:
          binary_data:
            type: binary
          written_length:
            type: integer
            desc: Data length that was written as body.
      AT+UHTCRPUH:
        brief: HTTP Client Request PUT Header
        desc: Get the HTTP header that would be used in a **PUT** request using the
          current configuration
        syntax:
          AT+UHTCRPUH=<session_id>:
            api_name: GetPutRequestHeader
            desc: Return the HTTP header for a PUT request
            responses:
              +UHTCRPUH:<session_id>,<header_data>:
                desc: Read the header of the current request.
    urcs:
      +UEHTCDC:<session_id>:
        api_name: Disconnect
        brief: Event HTTP Client Disconnected
        desc: Disconnected from HTTP server
      +UEHTCRS:<session_id>,<status_code>,<description>:
        api_name: RequestStatus
        brief: Event HTTP Client Request Status
        desc: Response status from the latest HTTP request.
        parameters:
          status_code:
            type: integer
            desc: HTTP status code
          description:
            type: string
            desc: Description of the status code
  Network Time:
    type_prefix: ntp
    desc: Network Time AT commands
    commands:
      AT+UNTE:
        brief: Set/Get NTP client status
        syntax:
          AT+UNTE=<client_status>:
            storable: true
            api_name: SetClientEnabled
            desc: Enable/disable NTP client
          AT+UNTE?:
            api_name: GetClientEnabled
            desc: Read NTP client status
            responses:
              +UNTE:<client_status>:
                desc: NTP client status
        parameters:
          client_status:
            desc: Enable/disable NTP client
            type: enumerator
            values:
              disable:
                desc: (Factory default) Disable NTP client
                value: 0
              enable_manual:
                desc: Enable NTP client using NTP servers configured by AT+UNTSC
                value: 1
              enable_auto:
                desc: Enable NTP client using NTP servers configured by DHCP if exists,
                  otherwise use NTP servers configured by AT+UNTSC
                value: 2
      AT+UNTSC:
        brief: Set/Get NTP servers
        syntax:
          AT+UNTSC=<ntp_server_id>,<ntp_server_address>:
            storable: true
            api_name: SetNtpServer
            desc: Set NTP servers
            notes: To remove this NTP server address, set it to empty string ("")
          AT+UNTSC?:
            api_name: GetNtpServer
            desc: Read the information of NTP servers currently being used
            notes: the NTP servers could come from DHCP offer or be configured via
              AT+UNTSC depending on the NTP client configuration and network environment.
            responses:
              +UNTSC:<ntp_server_id>,<ntp_server_address>,<ntp_server_ip>,<reachable>:
                desc: NTP server information
        parameters:
          ntp_server_id:
            desc: NTP server
            type: integer
            valid_values: 0..4
          ntp_server_address:
            desc: NTP server address (Fully Qualified Domain name or IP address)
            type: string
          ntp_server_ip:
            desc: NTP server IP address
            type: ip_addr
          reachable:
            desc: NTP server reachability
            type: enumerator
            values:
              no:
                desc: NTP server is unreachable
                value: 0
              yes:
                desc: NTP server is reachable
                value: 1
  Security:
    type_prefix: sec
    desc: Security AT commands
    parameters:
      password:
        type: string
        length: 1..64
        desc: "Decryption password; applicable only for PKCS8 encrypted client private\
          \ keys. The maximum length is 64 characters.\nNOTE: Supported Encryption\
          \ method for private keys is AES only\n"
      cert_type:
        type: cert_type
      name:
        type: string
        length: 1..32
    commands:
      AT+USECR:
        brief: Security Certificate Remove
        syntax:
          AT+USECR=<cert_type>,<name>:
            api_name: CertificateRemove
            desc: Remove a single X.509 certificate or private key.
          AT+USECR:
            api_name: CertificateRemoveAll
            desc: Remove all X.509 certificates and private keys.
      AT+USECUB:
        input_payload: binary
        brief: Security Certificate Upload Binary
        notes: Note that the size of the certificate can be maximum 15360 bytes and
          that maximum 8 certs (or cert chains) can be stored simultaneously
        syntax:
          AT+USECUB=<cert_type>,<name>{binary_data}:
            api_name: CertificateUpload
            desc: Write an X.509 certificate or private key using binary transfer.
          AT+USECUB=<cert_type>,<name>,<password>{binary_data}:
            api_name: CertificateUploadPW
            desc: Write an X.509 certificate or private key with password using binary
              transfer.
        parameters:
          binary_data:
            type: binary
            desc: The certificate data.
      AT+USECUBI:
        visibility: internal
        input_payload: binary
        brief: Security Certificate Upload Binary (Internal Version)
        syntax:
          AT+USECUBI=<cert_type>,<name>{binary_data}:
            desc: Write an X.509 certificate or private key using binary transfer.  This
              command will write the cert to internal storage. Can not be removed
              or used by another at command
          AT+USECUBI=<cert_type>,<name>,<password>{binary_data}:
            desc: Write an X.509 certificate or private key with password using binary
              transfer.  This command will write the cert to internal storage. Can
              not be removed or used by another at command
        parameters:
          binary_data:
            type: binary
            desc: The certificate data.
      AT+USECL:
        brief: Security Certificates List
        syntax:
          AT+USECL?:
            desc: Read all uploaded certificate names
            api_name: ListCertificates
            multiline_response: true
            responses:
              +USECL:<cert_type>,<name>:
                desc: Successful read response. Note that there will be one response
                  per certificate
      AT+USECLI:
        brief: Security Certificates List internal
        visibility: internal
        syntax:
          AT+USECLI?:
            desc: Read all uploaded internal certificate names
            responses:
              +USECLI:<cert_type>,<name>:
                desc: Successful read response. Note that there will be one response
                  per certificate
      AT+USECD:
        brief: Security Certificates Details
        syntax:
          AT+USECD=<name>:
            desc: Read certificate details
            api_name: ReadAllCertificatesDetails
            response_syntax_param: cert_detail_id
            responses:
              +USECD:<cert_detail_id>,<hex_value>:
                response_syntax_values:
                - 0
                desc: Read response for hex values
              +USECD:<cert_detail_id>,<int_value>:
                response_syntax_values:
                - 1
                desc: Read response for certificate size
          AT+USECD=<name>,<cert_detail_id>:
            desc: Read certificate details
            api_name: ReadCertificatesDetails
            response_syntax_param: cert_detail_id
            responses:
              +USECD:<cert_detail_id>,<hex_value>:
                response_syntax_values:
                - 0
                desc: Read response for hex values
              +USECD:<cert_detail_id>,<int_value>:
                response_syntax_values:
                - 1
                desc: Read response for certificate size
        parameters:
          cert_detail_id:
            type: enumerator
            values:
              fingerprint:
                value: 0
                desc: The fingerprint of the certificate, returns hex_value
              certificate_size:
                value: 1
                desc: The size of the certificate, returns int_value
              not_before_date:
                value: 2
                desc: Certificate not valid before date, returns hex_value
              not_after_date:
                value: 3
                desc: Certificate not valid after date, returns hex_value
          hex_value:
            type: byte_array
            desc: Hex value
          int_value:
            type: integer
            desc: Integer value
      AT+USETE:
        brief: Security TLS Extensions
        syntax:
          AT+USETE?:
            desc: Read all TLS extension settings
            api_name: ListTlsExtensions
            multiline_response: true
            responses:
              +USETE:<extension>,<enabled>:
                desc: Successful read response
        parameters:
          extension:
            type: enumerator
            values:
              sni:
                value: 0
                desc: Server Name Extension
              fragmentation:
                value: 1
                desc: Handshake fragmentation
          enabled:
            type: enabled
      AT+USETE0:
        brief: Security TLS Extensions Server Name Indication
        syntax:
          AT+USETE0=<enabled>:
            storable: true
            api_name: SetTlsServerNameIndication
            desc: Turn Server Name Indication TLS extension on and off on a system
              level
          AT+USETE0?:
            api_name: GetTlsServerNameIndication
            desc: Read Server Name Indication setting
            responses:
              +USETE0:<enabled>:
                desc: Successful read response
        parameters:
          enabled:
            type: enabled
      AT+USETE1:
        brief: Security TLS Extensions Handshake Fragmentation
        syntax:
          AT+USETE1=<enabled>:
            storable: true
            api_name: SetTlsHandshakeFrag
            desc: Turn Handshake Fragmentation TLS extension on and off on a system
              level
          AT+USETE1?:
            api_name: GetTlsHandshakeFrag
            desc: Read Handshake Fragmentation setting
            responses:
              +USETE1:<enabled>:
                desc: Successful read response
        parameters:
          enabled:
            type: enabled
      AT+USETL:
        visibility: hidden
        brief: Security TLS Logging
        syntax:
          AT+USETL=<tls_log_level>:
            desc: Set tls log level
            notes: "This setting is not persistent after restart. \nIMPORTANT: this\
              \ logging is a security risk, do not ever use this logging in a real\
              \ world scenario. This is only available in debug FW for this reason\n"
        parameters:
          tls_log_level:
            type: tls_log_level
  Power:
    commands:
      AT+UPMDS:
        brief: Power Management Deep Sleep
        syntax:
          AT+UPMDS:
            api_name: DeepSleepWithGpioWakeup
            desc: Enter Deep Sleep Mode with GPIO wakeup.
          AT+UPMDS=<wakeup_mode>:
            api_name: DeepSleep
            desc: Enter Deep Sleep Mode with specified wakeup mode.
        parameters:
          wakeup_mode:
            type: enumerator
            desc: Selects how to wake up from deep sleep.
            default: 0
            values:
              wakeup_gpio:
                value: 0
                desc: Wakeup by pulling the module wakeup pin low.
      AT+UPMPSL:
        brief: Power Management Power Save Level
        syntax:
          AT+UPMPSL=<level>:
            api_name: SetPowerSaveLevel
            desc: Set Power Save Level.
          AT+UPMPSL?:
            api_name: GetPowerSaveLevel
            desc: Read Power Save Level.
            responses:
              +UPMPSL:<level>:
                desc: Response with current Power Save Level.
        parameters:
          level:
            type: integer
            desc: Power save level
            default: 0
            valid_values: 0..1
      AT+UPMPSTO:
        brief: Power Management Power Save Timeout
        syntax:
          AT+UPMPSTO=<timeoutMs>:
            api_name: SetPowerSaveTimeout
            desc: Set Power Save active state timeout in milli second .
          AT+UPMPSTO?:
            desc: Read Power Save active state TO.
            responses:
              +UPMPSTO:<timeoutMs>:
                desc: Response with current active state timeout value in milli second.
        parameters:
          timeoutMs:
            type: integer
            desc: Active state timeout ms
            default: 1000
            valid_values: 1..60000
  Transparent:
    desc: "Transparent Mode AT commands. In transparent mode all data that is sent\
      \ from the host to the UART is\nforwarded to the socket or SPS link that is\
      \ configured for transparent mode, and the all data that arrives\non this link\
      \ is sent to the UART.\nTransparent mode is limited to one link at a time.\n"
    parameters:
      link_type:
        type: enumerator
        values:
          sps:
            desc: BLE SPS Link
            value: 0
          socket:
            desc: Socket
            value: 1
      link_type_read:
        type: enumerator
        values:
          none:
            desc: No link type set
            value: -1
          sps:
            desc: BLE SPS Link
            value: 0
          socket:
            desc: Socket
            value: 1
    commands:
      AT+UTM:
        brief: Transparent Mode
        desc: Use this command to directly switch to transparent mode for a specific
          SPS link or a socket.
        syntax:
          AT+UTM=<link_type>,<handle>:
            desc: Enter Transparent Mode
        parameters:
          handle:
            desc: "For SPS links, set this to the connection handle\nFor sockets,\
              \ set this to the socket handle\n"
            type: integer
      AT+UTMP:
        brief: Transparent Mode Persistent
        desc: This command is used for automatically setting up a transparent mode
          connection on boot.
        syntax:
          AT+UTMP=<link_type>,<config_id>:
            storable: true
            requires_reboot: true
            desc: Set persistent transparent mode for link
          AT+UTMP?:
            desc: Get current persistent transparent mode configuration
            responses:
              +UTMP:<link_type_read>,<config_id>:
                desc: Successful read response.
        parameters:
          config_id:
            desc:
            - For SPS, set this to the config_id returned by ${ref:AT+UBTP}.
            - For sockets, set this to the config_id returned by ${ref:AT+USOP}.
            type: integer
      AT+UTMPC:
        brief: Transparent Mode Persistent Clear
        desc: Clears the persistent link configuration for transparent mode.
        syntax:
          AT+UTMPC:
            storable: true
            desc: Clears persistent transparent mode settings
  Diagnostics:
    type_prefix: diag
    desc: Diagnostics Tools
    urcs:
      +UEDGPC:<transmitted_packets>,<received_packets>,<packet_loss_rate>,<avg_response_time>:
        api_name: PingComplete
        brief: Event Ping Complete
        desc: Event is sent out with a summary of the ping results after all packets
          are transmitted.
        parameters:
          transmitted_packets:
            type: integer
            desc: Total number of packets transmitted successfully.
          received_packets:
            type: integer
            desc: Total number of packets received successfully.
          packet_loss_rate:
            type: integer
            desc: Packet loss rate in percentage between transmitted and received
              packets.
          avg_response_time:
            type: integer
            desc: Average ping response time in milliseconds.
      +UEDGP:<ping_response>,<response_time>:
        api_name: PingResponse
        brief: Event Ping Response
        desc: Event is sent out when a single ping has a result.
        parameters:
          ping_response:
            type: enumerator
            desc: Ping Response result. 0 - ping failed, 1 - ping successful
            values:
              false:
                desc: Ping failed.
                value: 0
              true:
                desc: Ping succeeded.
                value: 1
          response_time:
            type: integer
            desc: Ping response time in milliseconds.
      +UEDGI:<iperf_output>:
        api_name: IperfOutput
        brief: Event Iperf output
        desc: Event is sent out for all output string send by iperf tool
        parameters:
          iperf_output:
            type: string
            length: 0..99
            desc: Iperf readable output string
    commands:
      AT+UDGP:
        brief: Diagnostics Ping
        desc: Send a ping command.
        syntax:
          AT+UDGP=<destination>[,<count>]:
            api_name: Ping
            desc: Sends a ping command to a destination address every second, repeating
              it (count) times.
        parameters:
          destination:
            type: string
            desc: Destination host to send a ping call to in the form of an IPv4 address
              (i.e. 192.168.1.10) or hostname (i.e. www.u-blox.com).
            length: 4..80
          count:
            type: integer
            desc: The number of pings (or packets) that will be transmitted. 0 means
              ping continuously.
            default: 4
            valid_values: 0..65535
      AT+UDGSP:
        brief: Diagnostics Stop Ping
        syntax:
          AT+UDGSP:
            api_name: PingStop
            desc: "This command will stop any ping in progress.\n"
            notes: The command is asynchronous, and the ping will not be interrupted
              immediately, but right after the next ping packet has a response, which
              might take a few seconds if the packet response times out. This command
              always returns OK and does nothing if there is no ping in progress.
      AT+UDGI:
        brief: Diagnostics Iperf
        syntax:
          ? AT+UDGI=<iperf_action>,<protocol_type>[,<role>,<port>,<report_interval>[,<time_boundary>,<ip_addr>[,<length>[,<bandwidth>[,<bidirectional>]]]]]
          : api_name: Iperf
            desc: Start/stop IPERF 2 server/client
        parameters:
          iperf_action:
            desc: Action
            type: enumerator
            values:
              start:
                desc: Start iperf
                value: 1
              stop:
                desc: Stop iperf
                value: 2
          protocol_type:
            desc: IP protocol
            type: enumerator
            values:
              tcp:
                desc: TCP
                value: 1
              udp:
                desc: UDP
                value: 2
          role:
            desc: Role
            type: enumerator
            values:
              server:
                desc: Server
                value: 1
              client:
                desc: Client
                value: 2
          port:
            desc: Port
            type: integer
          report_interval:
            desc: Report interval
            type: integer
          time_boundary:
            desc: Time boundary. Client only. Ignored if role is server
            type: integer
          ip_addr:
            desc: IP address to connect to. Client only. Ignored if role is server
            type: ip_addr
          bandwidth:
            desc: Bandwidth to be used for UDP
            type: integer
          length:
            desc: Size of packets.
            default: 1460
            type: integer
            valid_values: 1..1460
          bidirectional:
            desc: Bidirectional flag. Client only. Ignored if role is server
            type: enumerator
            values:
              off:
                desc: Off
                value: 0
              on:
                desc: "On\nWhen starting bidirectional TCP test, start a server on\
                  \ both tester and DUT, then start a client with bidirectional flag\
                  \ on the DUT.\nIf doing bidirectional UDP test, start a server on\
                  \ both DUT and tester and then start a client with a bidirectional\
                  \ flag on both.\n"
                value: 1
      AT+UDPUS:
        visibility: hidden
        brief: Print UART Stats
        syntax:
          AT+UDPUS?:
            desc: Prints UART stats on the log.
            responses:
              +UDPUS:<stats_log>:
                desc: UART stats log
        parameters:
          stats_log:
            type: string
type_group:
  Shared:
    type_prefix: ''
    param_types:
      interface_id:
        type: enumerator
        values:
          bluetooth:
            desc: Bluetooth
            value: 0
          wifi_station:
            desc: Wi-Fi station
            value: 1
          wifi_ap:
            desc: Wi-Fi Access point
            value: 2
      read_mode:
        desc: Modes to read data in AT
        type: enumerator
        values:
          buffered:
            value: 0
            desc: Buffered mode
          direct_string:
            value: 1
            desc: Direct String mode
          direct_binary:
            value: 2
            desc: Direct Binary Mode
      enabled:
        type: enumerator
        values:
          no:
            value: 0
            desc: Disabled
          yes:
            value: 1
            desc: Enabled
  bootloader:
    type_prefix: ''
    param_types:
      bootloader_mode:
        type: enumerator
        values:
          xmodem:
            desc: Enter xmodem mode for u-connect software update using serial port.
            value: 0
          command_line:
            desc: Enter the bootloader command line mode using serial port.
            value: 1
  Bluetooth:
    type_prefix: bt
    param_types:
      mode:
        type: enumerator
        values:
          disabled:
            desc: Disabled.
            value: 0
          central:
            desc: "Bluetooth Low Energy Central.\nIn this mode, starting advertisements,\
              \ direct advertisements and other functions associated\nwith the Peripheral\
              \ role is not possible.\n"
            value: 1
          peripheral:
            desc: "Bluetooth Low Energy Peripheral.\nIn this mode, initiating connections,\
              \ discovery and other functions associated with\nthe Central role is\
              \ not possible.\n"
            value: 2
          central_peripheral:
            desc: Bluetooth Low Energy Simultaneous Central and Peripheral. This is
              the factory default.
            value: 3
      adv_mode:
        type: enumerator
        values:
          advertisements_off:
            desc: Set Bluetooth Advertisements off
            value: 0
          advertisements_on:
            desc: Set Bluetooth Advertisements on
            value: 1
      security_mode:
        type: enumerator
        default: 0
        values:
          none:
            desc: Security not required. No encryption enforced.
            value: 0
          unauthenticated:
            desc: Require at least unauthenticated bonding.
            value: 1
          authenticated:
            desc: Require authenticated bonding. No secure connections.
            value: 2
          authenticated_secure_connection:
            desc: Require authenticated bonding. Support secure connections. Fallback
              to simple pairing if the remote side does not support secure connections.
            value: 3
          authenticated_secure_connection_only:
            desc: Require authenticated bonding. Strictly uses secure connections.
            value: 4
  Wi-Fi:
    param_types:
      reg_domain:
        desc: Regulatory domain
        type: enumerator
        values:
          world:
            desc: "World\nSupported Channels;\n1-11\n36,40,44,48\n52,56,60,64\n"
            value: 0
          etsi:
            desc: "ETSI\nSupported Channels;\n1-13\n36,40,44,48\n52,56,60,64\n100,104,108,112,116,120,124,128,132,136,140\n\
              149,153,157,161,165\n"
            value: 1
          fcc:
            desc: "FCC\nSupported Channels;\n1-11\n36,40,44,48\n52,56,60,64\n100,104,108,112,116,120,124,128,132,136,140\n\
              144\n149,153,157,161,165\n"
            value: 2
          ic:
            value: 3
            desc: "IC/ISED\nSupported Channels;\n1-11\n36,40,44,48\n52,56,60,64\n\
              100,104,108,112,116,132,136,140\n144\n149,153,157,161,165\n"
          nz:
            value: 4
            desc: "NZ\nSupported Channels;\n1-13\n36,40,44,48\n52,56,60,64\n100,104,108,112,116,120,124,128,132,136,140\n\
              149,153,157,161,165\n"
          mkk:
            value: 5
            desc: "MKK/Japan\nSupported Channels;\n1-14\n36,40,44,48\n52,56,60,64\n\
              100,104,108,112,116,120,124,128,132,136,140\n144\n"
          ncc:
            value: 6
            desc: "NCC/Taiwan\nSupported Channels;\n1-11\n36,40,44,48\n52,56,60,64\n\
              100,104,108,112,116,120,124,128,132,136,140\n144\n149,153,157,161,165\n"
          acma:
            value: 7
            desc: "ACMA/AU\nSupported Channels;\n1-13\n36,40,44,48\n52,56,60,64\n\
              100,104,108,112,116,132,136,140\n149,153,157,161,165\n"
          kcc:
            value: 8
            desc: "KCC/South Korea\nSupported Channels;\n1-13\n36,40,44,48\n52,56,60,64\n\
              100,104,108,112,116,120,124,128,132,136,140\n144\n149,153,157,161,165\n"
          sa:
            value: 9
            desc: "SA/South Africa\nSupported Channels;\n1-13\n36,40,44,48\n52,56,60,64\n\
              100,104,108,112,116,120,124,128,132,136,140\n"
          br:
            value: 10
            desc: "Brazil\nSupported Channels;\n1-13\n36,40,44,48\n52,56,60,64\n100,104,108,112,116,120,124,128,132,136,140\n\
              149,153,157,161,165\n"
      security_mode:
        desc: The current security mode.
        type: enumerator
        values:
          open:
            value: 0
            desc: Open security
          wpa:
            value: 1
            desc: WPA security
          eap:
            value: 2
            desc: EAP-TLS security
          peap:
            value: 3
            desc: PEAP security
      ip_mode:
        desc: IP assignment
        type: enumerator
        values:
          dhcp:
            value: 0
            desc: DHCP
          static:
            value: 1
            desc: Static IP
      tls_version:
        type: enumerator
        desc: TLS version to use
        values:
          no_tls:
            desc: Disable TLS
            value: 0
          tls1_2:
            desc: TLS 1.2
            value: 1
          tls1_3:
            desc: TLS 1.3
            value: 2
          tls1_2_or_tls1_3:
            desc: TLS 1.2 or 1.3 (negotiate highest)
            value: 3
      ca_name:
        type: string
        desc: Name of the certificate authority (CA) certificate to use
        length: 1..32
      client_cert_name:
        type: string
        desc: Name of the client certificate to use
        length: 1..32
      client_key_name:
        type: string
        desc: Name of the private key for client certificate
        length: 1..32
      username:
        desc: User name for PEAP authentication.
        type: string
        length: 1..31
      identity:
        desc: Identity for EAP-TLS
        type: string
        length: 1..31
      wlan_handle:
        type: integer
        valid_values: 0..0
        desc: Handle to use for Wi-Fi config and connection
      ssid:
        desc: SSID
        type: string
        length: 0..32
      wpa_threshold:
        default: 0
        type: enumerator
        desc: Lowest WPA version to connect to
        values:
          wpa2:
            value: 0
            desc: Only connect to access points that support WPA2 or up
          wpa3:
            value: 1
            desc: Only connect to access points that support WPA3
      adaptivity_type:
        type: enumerator
        values:
          auto:
            value: 0
            desc: Auto, depends on regulatory domain
          disabled:
            value: 1
            desc: Force disabled
          enabled:
            value: 2
            desc: Force enabled
          carrier_sense:
            value: 3
            desc: Force Carrier sense (MIC)
  MQTT:
    param_types:
      qos:
        desc: Quality of Service (QoS) for the message or topic
        type: enumerator
        default: 0
        values:
          at_most_once:
            value: 0
            desc: At most once
          at_least_once:
            value: 1
            desc: At least once
          exactly_once:
            value: 2
            desc: Exactly once
  Security:
    type_prefix: sec
    param_types:
      cert_type:
        type: enumerator
        values:
          root:
            value: 0
            desc: Root certificate
          client:
            value: 1
            desc: Client certificate
          key:
            value: 2
            desc: Client private key
      tls_log_level:
        type: enumerator
        values:
          off:
            value: 0
            desc: Logging off
          error:
            value: 1
            desc: Error Logging
          state:
            value: 2
            desc: State change Logging
          info:
            value: 3
            desc: Informational Logging
          verbose:
            value: 4
            desc: Verbose Logging
settings:
  AtServer:
    EchoOn:
      id: 1
      type: bool
      default: true
      desc: When set to true the AT server will echo all data
    UseExtendedError:
      id: 2
      type: bool
      default: false
      desc: When set to true server will return error code on error
    LineTermChar:
      id: 3
      type: char
      default: \r
      desc: Line termination character (typically '\r')
    RespFormatChar:
      id: 4
      type: char
      default: \n
      desc: Response format character (typically '\n')
    BackspaceChar:
      id: 5
      type: char
      default: \b
      desc: Backspace character (typically '\b')
    EscapeChar:
      id: 38
      type: char
      default: 43
      desc: Escape sequence character
    EscapeSequencePreTimeout:
      id: 39
      type: uint16_t
      default: 1000
      desc: Minimum time (ms) of no data activity required before the escape sequence
        is sent
    EscapeSequencePostTimeout:
      id: 40
      type: uint16_t
      default: 1000
      desc: Minimum time (ms) of no data activity required after the escape sequence
        is sent
    EscapeSequenceWithinTimeout:
      id: 41
      type: uint16_t
      default: 200
      desc: Maximum time interval (ms) between escape characteres
  Uart:
    BaudRate:
      id: 6
      type: uint32_t
      default: 115200
      desc: UART baudrate in bps
    UseFlowControl:
      id: 7
      type: bool
      default: false
      desc: Set to true if HW flow control should be used (CTS/RTS)
  Greeting:
    Message:
      id: 8
      type: char[50]
      default: +STARTUP
      desc: Startup greeting
    Show:
      id: 9
      type: uint8_t
      default: 1
      desc: Set to true if startup greeting should be shown on startup
  CustomAddress:
    Bluetooth:
      id: 10
      type: uMacAddress_t
      default: 0
      desc: Custom bluetooth address
    WiFiSta:
      id: 11
      type: uMacAddress_t
      default: 0
      desc: Custom WiFi station address
  Gap:
    AdvertiseData:
      id: 12
      type: uByteArray_t
      default: 0
      desc: Advertise data
    ConnIntervalMin:
      id: 13
      type: uint32_t
      default: 24
      desc: Connection interval minimum
    ConnIntervalMax:
      id: 14
      type: uint32_t
      default: 40
      desc: Connection interval maximum
    ConnPeripheralLatency:
      id: 15
      type: uint32_t
      default: 0
      desc: Connection peripheral latency
    ConnLinklossTimeout:
      id: 16
      type: uint32_t
      default: 2000
      desc: Connection linkloss timeout
    PreferredTxPHY:
      id: 81
      type: uint8_t
      default: 0
      desc: Preferred Transmitter PHY
    PreferredRxPHY:
      id: 82
      type: uint8_t
      default: 0
      desc: Preferred Reciever PHY
    IoCapabilities:
      id: 18
      type: uint32_t
      default: 0
      desc: IO Capabilities
    SecurityMode:
      id: 19
      type: uint32_t
      default: 0
      desc: Bonding Security Mode
    PairingMode:
      id: 20
      type: uint32_t
      default: 0
      desc: Pairing Mode
    ChannelSoundingMode:
      id: 129
      type: uint32_t
      default: 0
      desc: Channel Sounding mode (0=off
      1=reflector:
      2=initiator:
      3=both):
    ChannelSoundingAntennas:
      id: 130
      type: uint32_t
      default: 1
      desc: Number of CS antennas (1 or 2)
    ChannelSoundingRate:
      id: 131
      type: uint32_t
      default: 0
      desc: CS update rate (0=200ms
      1=100ms:
      2=5000ms):
    LocalName:
      id: 42
      type: char[30]
      default: ''
      desc: Local name of Bluetooth device
    ManufacturerName:
      id: 43
      type: char[32]
      default: u-blox
      desc: Manufacturer name for DIS
    ModelName:
      id: 44
      type: char[21]
      default: ''
      desc: Model Name for DIS
    FirmwareRevision:
      id: 45
      type: char[21]
      default: ''
      desc: Firmware revision for DIS
    SoftwareRevision:
      id: 46
      type: char[21]
      default: ''
      desc: Software revision for DIS
    AdvertisementMode:
      id: 47
      type: uint32_t
      default: 0
      desc: Advertisement mode
      on or off:
    BluetoothMode:
      id: 50
      type: uint32_t
      default: '3'
      desc: Bluetooth mode
    CustomMaxTxPower:
      id: 126
      type: int8_t
      default: 127
      desc: Custom Max TX power in dBm
      integer part:
    CustomMaxTxPowerDecimal:
      id: 127
      type: uint8_t
      default: 0
      desc: Custom Max TX power in dBm
      decimal part:
    AdvIntervalMin:
      id: 51
      type: uint32_t
      default: 1600
      desc: Advertising interval minimum
    AdvIntervalMax:
      id: 52
      type: uint32_t
      default: 2000
      desc: Advertising interval maximum
    ScanInterval:
      id: 112
      type: uint32_t
      default: 160
      desc: Scan interval
    ScanWindow:
      id: 113
      type: uint32_t
      default: 128
      desc: Scan window
    ConnectToDirectedAdvertisements:
      id: 124
      type: uint32_t
      default: 0
      desc: Connect to directed advertisements during scanning 0 = off
      1 = on):
    ScanResponseData:
      id: 59
      type: uByteArray_t
      default: 0
      desc: Scan response data
  ExtAdv[2]:
    AdvertisementMode:
      id: 120
      type: uint32_t
      default: 0
      desc: Advertisement mode
      on or off:
    AdvertiseData:
      id: 121
      type: uByteArray_t
      default: 0
      desc: Extended Advertisement data
  SPS:
    EnableService:
      id: 62
      type: uint32_t
      default: 0
      desc: Enable SPS service on restart
  Wifi:
    RegulatoryDomain:
      id: 17
      type: uint8_t
      default: 0
      desc: Regulatory domain for WiFi
    HostName:
      id: 92
      type: char[41]
      default: ''
      desc: Host Name for Wi-Fi interfaces.
    FortyMhzEnabled:
      id: 94
      type: bool
      default: false
      desc: 40 Mhz channels
    Adaptivity:
      id: 95
      type: int32_t
      default: 0
      desc: Wifi Adaptivity settings. 0 = off
      1 = on:
      2 = carrier sense:
    AdaptivityThreshold:
      id: 96
      type: uint8_t
      default: 242
      desc: Wifi Adaptivity threshold
    ShouldReconnect:
      id: 98
      type: bool
      default: true
      desc: Wifi Station Auto reconnect
    ChannelFilter:
      id: 109
      type: uByteArray_t
      default: 0
      desc: Wifi channel filter
    ChannelFilterEnabled:
      id: 110
      type: bool
      default: false
      desc: Set to true if the Wifi channel filter should be used
    CustomMaxTxPower:
      id: 125
      type: int8_t
      default: 127
      desc: Custom Max TX power in dBm
      integer part:
    CustomMaxTxPowerDecimal:
      id: 128
      type: uint8_t
      default: 0
      desc: Custom Max TX power in dBm
      decimal part:
  WifiStationConfig:
    StationSsid:
      id: 21
      type: char[33]
      default: UBXWifi
      desc: Wifi station config Ssid
    StationAuthMode:
      id: 22
      type: int32_t
      default: 0
      desc: Wi-Fi Station config authentication mode
    StationPassPhrase:
      id: 23
      type: char[64]
      default: ''
      desc: Wi-Fi Station config password
    StationStaticIpOn:
      id: 24
      type: bool
      default: false
      desc: Wi-Fi Station config static ip/dhcp flag
    StationStaticIpAddress:
      id: 25
      type: uSockIpAddress_t
      default: 0
      desc: Ip address to use if IP config is static
    StationStaticIpSubNetMask:
      id: 26
      type: uSockIpAddress_t
      default: 0
      desc: Subnet mask to use if IP address config is static
    StationStaticIpGateWay:
      id: 27
      type: uSockIpAddress_t
      default: 0
      desc: Gateway to use if IP address config is static
    StationStaticIpPrimDns:
      id: 28
      type: uSockIpAddress_t
      default: 0
      desc: Primary DNS server to use if IP address config is static
    StationStaticIpSecDns:
      id: 29
      type: uSockIpAddress_t
      default: 0
      desc: Secondary DNS server to use if IP address config is static
    StationCaCertName:
      id: 30
      type: char[33]
      default: ''
      desc: Ca cert to use if authmode is eap or peap
    StationClientCertName:
      id: 31
      type: char[33]
      default: ''
      desc: Client cert to use if authmode is eap
    StationClientKeyName:
      id: 32
      type: char[33]
      default: ''
      desc: Client Private Key to use if authmode is eap
    StationIsActive:
      id: 58
      type: bool
      default: false
      desc: Wi-Fi Station is active
    StationUserName:
      id: 86
      type: char[32]
      default: ''
      desc: Username to use when connecting using EAP and PEAP
    StationEnterprisePassw:
      id: 87
      type: char[32]
      default: ''
      desc: Password to use when connecting using EAP and PEAP
    StationPeapUseCa:
      id: 89
      type: bool
      default: false
      desc: Use ca Cert in peap authentication
    StationEapTlsIdentity:
      id: 111
      type: char[32]
      default: ''
      desc: Identity to use when connecting using EAP-TLS
    StationTlsVersion:
      id: 123
      type: int32_t
      default: 0
      desc: TLS version to use for EAP-TLS. 0 means no TLS is set
      then by default is TLS 1.2:
  WifiApConfig:
    APSsid:
      id: 33
      type: char[33]
      default: UBXWifi
      desc: Wi-Fi Access Point config Ssid
    APAuthMode:
      id: 34
      type: int32_t
      default: 0
      desc: Wi-Fi Access Point config authentication mode
    APPassPhrase:
      id: 35
      type: char[64]
      default: ''
      desc: Wi-Fi Access Point config password
    APChannel:
      id: 36
      type: int32_t
      default: 6
      desc: Wi-Fi Access Point config channel to start on
    APIsActive:
      id: 37
      type: bool
      default: false
      desc: Wi-Fi Access Point is active
    APHiddenSsid:
      id: 114
      type: bool
      default: false
      desc: Wi-Fi Access Point config hidden SSID
  WifiRoaming:
    RoamingEnabled:
      id: 99
      type: bool
      default: false
      desc: Enable roaming
    BackgroundScanningThreshold:
      id: 100
      type: int8_t
      default: -70
      desc: Roaming threshold to start background scanning
    RoamingSwitchThreshold:
      id: 101
      type: uint8_t
      default: 10
      desc: Roaming threshold to trigger switch to new AP
      relative to BackgroundScanningThreshold:
    RoamingScanInterval:
      id: 102
      type: uint32_t
      default: 1000
      desc: Roaming scan interval in milliseconds
    RoamingAggressiveEnabled:
      id: 103
      type: bool
      default: false
      desc: Enable aggressive roaming
    RoamingDelay:
      id: 106
      type: uint32_t
      default: 0
      desc: Roaming delay in milliseconds
    RoamingAllChannels:
      id: 107
      type: bool
      default: true
      desc: Roaming on all channels or on current channel only
  SockPersistentLink[3]:
    HostAddress:
      id: 48
      type: char[129]
      default: ''
      desc: Host address to connect to
    HostPort:
      id: 49
      type: uint16_t
      default: 0
      desc: The host port to connect to
    AddrTypeUseIPv6:
      id: 53
      type: bool
      default: false
      desc: Socket address type. Set to true for IPv6 or false for IPv4
    BinaryOpts:
      id: 54
      type: uint32_t
      default: 0
      desc: Binary mask for binary (on/off) socket options
    OptTcpKeepCnt:
      id: 55
      type: uint16_t
      default: 3
      desc: Socket option TCP_KEEPCNT
    OptTcpKeepIdle:
      id: 56
      type: uint16_t
      default: 3
      desc: Socket option TCP_KEEPIDLE
    OptTcpKeepIntvl:
      id: 57
      type: uint16_t
      default: 3
      desc: Socket option TCP_KEEPINTVL
    ShouldReconnect:
      id: 93
      type: bool
      default: true
      desc: Socket Connection state flag. If true the persistent socket will try to
        reconnect
    ProtocolType:
      id: 108
      type: int8_t
      default: 0
      desc: ProtocolType, TCP = 6, UDP = 17
    LocalPort:
      id: 118
      type: uint16_t
      default: 0
      desc: Local port to bind to
    Listen:
      id: 119
      type: bool
      default: false
      desc: Set to true if the socket should be listening
  Mqtt[1]:
    HostName:
      id: 63
      type: char[129]
      default: ''
      desc: Hostname to connect to
    Port:
      id: 64
      type: int32_t
      default: 0
      desc: Port
    ClientId:
      id: 65
      type: char[129]
      default: ''
      desc: Client id to use
      Note that if no client Id is supplied it will default to the mac address:
    UserName:
      id: 66
      type: char[129]
      default: ''
      desc: User name
    Password:
      id: 67
      type: char[129]
      default: ''
      desc: Password
    KeepAlive:
      id: 68
      type: int32_t
      default: 60
      desc: keepAlive
    LwtMsg:
      id: 69
      type: char[257]
      default: ''
      desc: Last Will and Testament message
    LwtTpc:
      id: 70
      type: char[257]
      default: ''
      desc: Last Will and Testament Topic
    LwtQos:
      id: 71
      type: int32_t
      default: 0
      desc: Last Will and Testament Qos
    LwtRetain:
      id: 72
      type: bool
      default: false
      desc: Last Will and Testament Retain flag
    LwtActive:
      id: 73
      type: bool
      default: false
      desc: Send Last Will and Testament on connection
    TlsVersion:
      id: 74
      type: int32_t
      default: 0
      desc: Lowest TLS version to use. 0 Means do not use tls
    CaCert:
      id: 75
      type: char[33]
      default: ''
      desc: Ca Cert to use for the connection
    ClientCert:
      id: 76
      type: char[33]
      default: ''
      desc: Client Cert to use for the connection
    ClientKey:
      id: 77
      type: char[33]
      default: ''
      desc: Client Private Key to use for the connection
    ServerNameIndication:
      id: 78
      type: bool
      default: true
      desc: Server Name Indication
  Security:
    TlsServerNameIndication:
      id: 90
      type: bool
      default: true
      desc: Enable/disable Server Name Indication extension
    TlsHandshakeFragment:
      id: 91
      type: bool
      default: true
      desc: Enable/disable handshake fragmentation extension
  NTPClient:
    Status:
      id: 115
      type: uint8_t
      default: 0
      desc: Enable/Disable NTP client
    OperationMode:
      id: 116
      type: uint8_t
      default: 0
      desc: Set NTP client operation mode
  NTPServers[5]:
    serverName:
      id: 117
      type: char[129]
      default: ''
      desc: FQDN or IP address of server
  ATReadMode:
    IpSockets:
      id: 60
      type: int32_t
      default: 0
      desc: Data in at receive data mode
    SpsData:
      id: 61
      type: int32_t
      default: 0
      desc: Data in AT receive mode for SPS
  Transparent:
    IdType:
      id: 79
      type: int8_t
      default: -1
      desc: Config ID type (SPS or socket - see uLinkType_t)
    ConfigId:
      id: 80
      type: int32_t
      default: 0
      desc: Config ID
  BlePersistentLink[3]:
    RemoteAddress:
      id: 83
      type: uMacAddress_t
      default: 0
      desc: Remote BLE address to connect to
    RemoteAddressType:
      id: 84
      type: uint8_t
      default: 0
      desc: Address type of the remote address
    SpsConnect:
      id: 85
      type: bool
      default: false
      desc: Should SPS be connected when link is up
    ShouldReconnect:
      id: 97
      type: bool
      default: true
      desc: BLE Connection state flag. If true the persistent ble connection will
        try to reconnect
  AutoPowerSave:
    PowerSaveLevel:
      id: 104
      type: int8_t
      default: 0
      desc: Set power save level
    PowerSaveTimeout:
      id: 105
      type: uint32_t
      default: 1000
      desc: Set power save timeout
  RadioCoex:
    Enable:
      id: 122
      type: bool
      default: false
      desc: Enable radio coexistence
product:
  model_name: NORA-W36
  software:
    name: u-connectXpress
    version:
      major: 3
      minor: 2
      patch: 0
